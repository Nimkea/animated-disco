Got it—thanks for sharing `main.tsx` and `App.tsx`. Your app already **tries** to prime CSRF (`initCSRFToken()` in `AppContent`) and uses a PWA service worker. The two reasons your “**Failed to generate challenge**” shows up are:

1. The wallet webview (MetaMask/Trust) isn’t logged in, so `/api/wallet/link/challenge` returns **401**.
2. The CSRF header isn’t guaranteed to be ready when the Link flow runs (and/or the SW caches an old 401/403).

Below is a small, reliable fix that makes the link flow resilient in **any** browser/webview and avoids SW interference.

---

## 1) Make CSRF guaranteed & reusable

Create a tiny helper that **fetches and caches** the CSRF token. (Works even if `initCSRFToken()` hasn’t run yet.)

```ts
// client/src/lib/csrf.ts
export async function ensureCsrf(): Promise<string> {
  const w = window as any;
  if (w.CSRF_TOKEN) return w.CSRF_TOKEN;

  const res = await fetch('/auth/csrf', { credentials: 'include', cache: 'no-store' });
  if (!res.ok) throw new Error('Failed to fetch CSRF token');

  const { csrfToken } = await res.json();
  w.CSRF_TOKEN = csrfToken;
  return csrfToken;
}
```

> Keep `initCSRFToken()` where it is; this helper just guarantees the token is available when a user taps “Link”.

---

## 2) Verify session (inside the wallet) before challenge

If the user is logged in on Chrome/Safari but **not** in MetaMask/Trust’s webview, the cookie isn’t there. Detect this and show a clear prompt.

```ts
// client/src/lib/auth.ts
export async function requireSession(): Promise<void> {
  const r = await fetch('/auth/me', { credentials: 'include', cache: 'no-store' });
  if (r.status === 401) {
    throw new Error('Please log in inside this browser (wallet webview) and try again.');
  }
  if (!r.ok) {
    throw new Error('Unable to verify session. Please refresh the page.');
  }
}
```

---

## 3) Harden the link flow (WalletConnect + CSRF + no SW cache)

Update your `LinkWalletCard` to:

* `await requireSession()`
* `await ensureCsrf()` and include `x-csrf-token` in **both** requests (safe even if `/challenge` doesn’t check CSRF)
* pass `credentials: 'include'` and `cache: 'no-store'` to avoid SW-cached responses
* handle 401/403 with friendly toasts

```ts
// client/src/components/link-wallet-card.tsx
import { ensureCsrf } from '@/lib/csrf';
import { requireSession } from '@/lib/auth';
...
const linkWallet = async () => {
  setLoading(true);
  let provider: any = null;
  let accounts: string[] = [];

  try {
    // 1) Must be authenticated in THIS webview
    await requireSession();

    // 2) CSRF guaranteed
    const csrf = await ensureCsrf();

    // 3) Choose provider (your existing logic)
    const hasInjected = !!(window as any).ethereum;
    const useWC = isMobile() && !hasInjected;

    if (useWC) {
      provider = await EthereumProvider.init({
        projectId: import.meta.env.VITE_WC_PROJECT_ID,
        chains: [56],
        showQrModal: true,
        metadata: {
          name: 'XNRT',
          description: 'XNRT - We Build the NextGen',
          url: window.location.origin,
          icons: [`${window.location.origin}/icon-192.png`],
        },
      });
      accounts = await provider.enable();
      setWcProvider(provider);
    } else if (hasInjected) {
      provider = (window as any).ethereum;
      accounts = await provider.request({ method: 'eth_requestAccounts' });
    } else {
      toast({
        variant: 'destructive',
        title: 'Wallet Connection Required',
        description:
          'Install MetaMask or Trust Wallet, or use WalletConnect to link your wallet.',
      });
      return;
    }

    const account = String(accounts?.[0] || '').toLowerCase();
    setAddress(account);

    // 4) Get challenge (no-store to bypass SW cache)
    const challengeRes = await fetch(
      `/api/wallet/link/challenge?address=${account}`,
      {
        credentials: 'include',
        cache: 'no-store',
        headers: { 'x-csrf-token': csrf },
      }
    );

    if (challengeRes.status === 401) {
      throw new Error('Please log in inside this browser and try again.');
    }
    if (challengeRes.status === 403) {
      throw new Error('Security token missing/invalid. Refresh the page and try again.');
    }
    if (!challengeRes.ok) {
      const e = await challengeRes.json().catch(() => ({}));
      throw new Error(e.message || 'Failed to get challenge');
    }

    const { message, nonce } = await challengeRes.json();

    // 5) Sign
    const signature = await provider.request({
      method: 'personal_sign',
      params: [message, account],
    });

    // 6) Confirm (CSRF + no-store)
    const confirmRes = await fetch('/api/wallet/link/confirm', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-csrf-token': csrf,
      },
      credentials: 'include',
      cache: 'no-store',
      body: JSON.stringify({ address: account, signature, nonce }),
    });

    if (confirmRes.status === 401) {
      throw new Error('Your session expired. Log in again and retry.');
    }
    if (confirmRes.status === 403) {
      throw new Error('Security token invalid. Refresh and try again.');
    }
    if (!confirmRes.ok) {
      const e = await confirmRes.json().catch(() => ({}));
      throw new Error(e.message || 'Failed to link wallet');
    }

    const result = await confirmRes.json();
    toast({
      title: '✅ Wallet Linked',
      description: `${result.address.slice(0, 6)}...${result.address.slice(-4)} is now linked`,
    });

    if (!linked.includes(result.address)) {
      setLinked((prev) => [result.address, ...prev]);
    }
  } catch (error: any) {
    console.error('Wallet linking error:', error);
    toast({
      variant: 'destructive',
      title: 'Linking Failed',
      description: error.message || 'Failed to link wallet. Please try again.',
    });
  } finally {
    setLoading(false);
  }
};
```

---

## 4) Keep your SW from caching API auth/wallet calls

Add (or keep) a **network-only** rule for `/auth/**` and `/api/**` in your service worker.

```ts
// client/src/sw.ts (or wherever you define runtime caching)
import { registerRoute } from 'workbox-routing';
import { NetworkOnly } from 'workbox-strategies';

registerRoute(({ url }) => url.pathname.startsWith('/auth/'), new NetworkOnly());
registerRoute(({ url }) => url.pathname.startsWith('/api/'), new NetworkOnly());
```

Rebuild so the SW picks up the new route, then hard-refresh (or tap your PWA update toast).

---

## 5) Server-side sanity (just confirm)

* `/api/wallet/link/challenge` should be **`requireAuth`** (401 if not logged in).
* `/api/wallet/link/confirm` should **enforce CSRF**.
* Cookies:

  * `sid` cookie: `httpOnly: true`, `sameSite: 'lax'`, `secure: true` in prod (you already do).
  * `csrfToken` cookie: non-httpOnly, `sameSite: 'lax'`, `secure: true` in prod (you already do).

---

### Why this fixes your error

* If the wallet webview wasn’t logged in → you now detect 401 and show a precise message.
* If CSRF wasn’t ready → `ensureCsrf()` guarantees the header + cookie pair before the request.
* If the SW served an old response → `cache: 'no-store'` + `NetworkOnly` ensures fresh network calls.

This keeps your security model intact and makes “Link with MetaMask” work reliably across mobile wallet browsers, WalletConnect, and desktop.
