Yes‚Äîhere‚Äôs a tight second-pass on those three files, with concrete ‚Äúfix-now‚Äù patches.

# üö® Highest-impact fixes

## 1) `hdWallet.ts` ‚Äî wrong coin type (still `714`)

MetaMask/BSC (EVM) uses **BIP44 coin type 60**, not 714 (BEP2). Also harden inputs.

**Patch (drop-in):**

```ts
// hdWallet.ts
import { ethers } from "ethers";

const MASTER_SEED_ENV = "MASTER_SEED";
// EVM/BSC derivation (MetaMask-compatible)
const BSC_DERIVATION_PATH = "m/44'/60'/0'/0";

export function deriveDepositAddress(derivationIndex: number): string {
  if (!Number.isInteger(derivationIndex) || derivationIndex < 0) {
    throw new Error("derivationIndex must be a non-negative integer");
  }
  const masterSeed = process.env[MASTER_SEED_ENV];
  if (!masterSeed) throw new Error("MASTER_SEED environment variable not set");

  const words = masterSeed.trim().split(/\s+/);
  if (!(words.length === 12 || words.length === 24)) {
    throw new Error("MASTER_SEED must be a 12 or 24 word mnemonic phrase");
  }
  const mnemonic = ethers.Mnemonic.fromPhrase(masterSeed.trim());
  const path = `${BSC_DERIVATION_PATH}/${derivationIndex}`;
  return ethers.HDNodeWallet.fromMnemonic(mnemonic, path).address.toLowerCase();
}

// Prefer 24 words (more entropy)
export function generateMasterSeed(): string {
  return ethers.Wallet.createRandom({ extraEntropy: ethers.randomBytes(32) }).mnemonic!.phrase;
}

// Keep validation consistent with the rest (mnemonic only)
export function validateMasterSeed(seed: string): boolean {
  try {
    const n = seed.trim().split(/\s+/).length;
    if (n !== 12 && n !== 24) return false;
    ethers.Mnemonic.fromPhrase(seed.trim()); 
    return true;
  } catch { return false; }
}

// Gate PK export behind an env flag
export function getDerivedPrivateKey(derivationIndex: number): string {
  if (process.env.ALLOW_SWEEPING_KEYS !== "true") throw new Error("Key export disabled");
  if (!Number.isInteger(derivationIndex) || derivationIndex < 0) throw new Error("Bad index");
  const seed = process.env[MASTER_SEED_ENV];
  if (!seed) throw new Error("MASTER_SEED not set");
  const m = ethers.Mnemonic.fromPhrase(seed.trim());
  const path = `${BSC_DERIVATION_PATH}/${derivationIndex}`;
  return ethers.HDNodeWallet.fromMnemonic(m, path).privateKey;
}
```

> If you already issued 714-path addresses, **don‚Äôt break them**. Keep scanning old ones, and store `derivationPath/coinType/addressVersion` in DB. Offer a ‚ÄúRotate address‚Äù that issues the new 60-path address.

---

## 2) `verifyBscUsdt.ts` ‚Äî add RPC timeout & single tip read

**Patch:**

```ts
import { ethers } from "ethers";

const DECIMALS_USDT_BSC = 18;

// Provider with 30s timeout
const req = new ethers.FetchRequest(process.env.RPC_BSC_URL!);
req.timeout = 30_000;
const provider = new ethers.JsonRpcProvider(req);

const USDT_ABI = ["event Transfer(address indexed from, address indexed to, uint256 value)"];
const usdt = new ethers.Contract(process.env.USDT_BSC_ADDRESS!, USDT_ABI, provider);

export async function verifyBscUsdtDeposit({ txHash, expectedTo, minAmount, requiredConf }: {
  txHash: string; expectedTo: string; minAmount?: number; requiredConf?: number;
}) {
  try {
    const need = requiredConf ?? Number(process.env.BSC_CONFIRMATIONS ?? 12);
    const [receipt, tip] = await Promise.all([
      provider.getTransactionReceipt(txHash),
      provider.getBlockNumber(),
    ]);
    if (!receipt) return { verified: false, confirmations: 0, reason: "Transaction not found" };

    const conf = tip - (receipt.blockNumber ?? 0);
    if (receipt.status !== 1) return { verified: false, confirmations: conf, reason: "Transaction failed" };

    let total = 0n;
    for (const log of receipt.logs) {
      if (log.address.toLowerCase() !== process.env.USDT_BSC_ADDRESS!.toLowerCase()) continue;
      try {
        const parsed = usdt.interface.parseLog({ topics: log.topics, data: log.data });
        if (parsed?.name !== "Transfer") continue;
        const to = (parsed.args as any).to as string;
        const value = (parsed.args as any).value as bigint;
        if (to.toLowerCase() === expectedTo.toLowerCase()) total += value;
      } catch { /* ignore */ }
    }
    if (total === 0n) return { verified: false, confirmations: conf, reason: "No USDT transfer to expected address" };

    const amount = Number(ethers.formatUnits(total, DECIMALS_USDT_BSC));
    if (typeof minAmount === "number" && amount + 1e-10 < minAmount) {
      return { verified: false, confirmations: conf, reason: `On-chain ${amount} USDT < claimed ${minAmount} USDT` };
    }
    if (conf < need) return { verified: false, confirmations: conf, amountOnChain: amount, reason: `Only ${conf}/${need} confirmations` };

    return { verified: true, confirmations: conf, amountOnChain: amount };
  } catch (e: any) {
    return { verified: false, confirmations: 0, reason: e?.message ?? "Verify error" };
  }
}
```

---

## 3) `depositScanner.ts` ‚Äî unreachable ‚Äúpending‚Äù branch + idempotency races

* You scan only up to `tip - REQUIRED_CONFIRMATIONS`, so `confirmations >= REQUIRED_CONFIRMATIONS` **always true** ‚Üí the ‚Äúpending‚Äù branch never runs. Either:

  * **Simplify**: remove pending logic (recommended), **or**
  * Scan to near-tip and add ‚Äúpending‚Üíapproved‚Äù updates.

* Add **DB uniqueness** to prevent race double-credits. Best is composite uniqueness on `(transactionHash, walletAddress)` (covers rare multi-recipient TXs).

**Prisma (sketch):**

```prisma
model Transaction {
  id              String  @id @default(cuid())
  userId          String
  transactionHash String
  walletAddress   String
  // ...
  @@unique([transactionHash, walletAddress])
}
```

**Credit path (idempotent):**

```ts
// inside processUserDeposit
await prisma.$transaction(async (tx) => {
  const exists = await tx.transaction.findUnique({
    where: { transactionHash_walletAddress: { transactionHash: txHash, walletAddress: toAddress } }
  });
  if (exists) return;

  await tx.transaction.create({
    data: {
      userId, type: "deposit",
      amount: new Prisma.Decimal(xnrtAmount),
      usdtAmount: new Prisma.Decimal(usdtAmount),
      transactionHash: txHash,
      walletAddress: toAddress,
      status: "approved",
      verified: true,
      confirmations,
      verificationData: { autoDeposit: true, blockNumber, scannedAt: new Date().toISOString() } as any
    }
  });

  await tx.balance.upsert({
    where: { userId },
    create: { userId, xnrtBalance: new Prisma.Decimal(xnrtAmount), totalEarned: new Prisma.Decimal(xnrtAmount) },
    update: { xnrtBalance: { increment: new Prisma.Decimal(xnrtAmount) }, totalEarned: { increment: new Prisma.Decimal(xnrtAmount) } },
  });
});
```

**Other nits:**

* Fail fast if `RPC_URL` or `USDT_ADDRESS` is missing (don‚Äôt default to `""`).
* Extract `const DECIMALS = 18;` and reuse.
* Consider grouping events by `transactionHash` and picking the **max** `confirmations` if you ever scan near tip.

---

## What to do next (quick)

1. Change the derivation path to **60** and redeploy.
2. Add the **unique constraint** shown above and switch to the idempotent credit.
3. Decide: keep mature-only scanning (remove pending branch) **or** support pending by scanning to tip and updating later.
4. (Optional) Add DB fields for `derivationPath/coinType/addressVersion` and keep scanning any legacy 714-path addresses you already issued.

If you share `schema.prisma`, I‚Äôll give you exact index/migration lines tailored to your models.
