✅ One-shot implementation plan (Replit Agent)
0) Dependencies
npm i ethers dotenv

1) Secrets (Replit → App Secrets)

Add/update:

RPC_BSC_URL=https://bsc-dataseed.binance.org
USDT_BSC_ADDRESS=0x55d398326f99059fF775485246999027B3197955
XNRT_WALLET=0x715C32deC9534d2fB34e0B567288AF8d895efB59
BSC_CONFIRMATIONS=12
XNRT_RATE_USDT=100
PLATFORM_FEE_BPS=50

2) Prisma models (if not added yet)

Edit prisma/schema.prisma and add/merge:

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  username  String?
  createdAt DateTime @default(now())
  deposits  Deposit[]
  balances  Balance[]
  trades    Trade[]
}

model Deposit {
  id              String   @id @default(cuid())
  userId          String
  user            User     @relation(fields: [userId], references: [id])
  network         String   // "BSC"
  asset           String   // "USDT"
  transactionHash String   @unique
  toAddress       String
  usdtAmount      Decimal  @db.Decimal(38,18)
  xnrtAmount      Decimal  @db.Decimal(38,18)
  status          String   // pending | approved | rejected
  verified        Boolean  @default(false)
  confirmations   Int      @default(0)
  proofImageUrl   String?
  adminNotes      String?
  raw             Json?
  createdAt       DateTime @default(now())
  processedAt     DateTime?

  @@index([status, createdAt])
  @@index([userId, createdAt])
}

model Balance {
  userId String
  asset  String
  amount Decimal @db.Decimal(38,18) @default(0)
  user   User    @relation(fields: [userId], references: [id])
  @@id([userId, asset])
}

model Trade {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id])
  fromAsset   String
  toAsset     String
  fromAmount  Decimal  @db.Decimal(38,18)
  toAmount    Decimal  @db.Decimal(38,18)
  rate        Decimal  @db.Decimal(38,18)
  fee         Decimal  @db.Decimal(38,18)
  refTx       String?
  createdAt   DateTime @default(now())

  @@index([userId, createdAt])
}


Generate/migrate (adjust to your flow):

npm run prisma:generate
# if you use Prisma migrate:
# npx prisma migrate dev -n "add-deposits-ledger"


If you prefer Drizzle, mirror the same columns/indexes in a migration; structure is what matters.

3) Helper: Prisma client

server/lib/prisma.ts

import { PrismaClient } from "@prisma/client";
export const prisma = new PrismaClient();

4) Verification service

server/services/verifyBscUsdt.ts

import "dotenv/config";
import { ethers } from "ethers";

const provider = new ethers.JsonRpcProvider(process.env.RPC_BSC_URL);
const ABI = ["event Transfer(address indexed from, address indexed to, uint256 value)"];
const usdt = new ethers.Contract(process.env.USDT_BSC_ADDRESS!, ABI, provider);

export type VerifyResult = {
  verified: boolean;
  confirmations: number;
  amountOnChain?: number;
  reason?: string;
};

export async function verifyBscUsdtDeposit(opts: {
  txHash: string;
  expectedTo: string;
  minAmount?: number;
  requiredConf?: number;
}): Promise<VerifyResult> {
  try {
    const { txHash, expectedTo } = opts;
    const need = opts.requiredConf ?? Number(process.env.BSC_CONFIRMATIONS ?? 12);

    const receipt = await provider.getTransactionReceipt(txHash);
    if (!receipt) return { verified: false, confirmations: 0, reason: "Transaction not found" };
    if (receipt.status !== 1) {
      const conf = (await provider.getBlockNumber()) - (receipt.blockNumber ?? 0);
      return { verified: false, confirmations: conf, reason: "Transaction failed" };
    }

    let toExpected = 0n;
    for (const log of receipt.logs) {
      if (log.address.toLowerCase() !== process.env.USDT_BSC_ADDRESS!.toLowerCase()) continue;
      try {
        const parsed = usdt.interface.parseLog({ topics: log.topics, data: log.data });
        if (parsed?.name !== "Transfer") continue;
        const to: string = (parsed.args as any).to;
        const value: bigint = (parsed.args as any).value;
        if (to.toLowerCase() === expectedTo.toLowerCase()) toExpected += value;
      } catch {}
    }

    const conf = (await provider.getBlockNumber()) - (receipt.blockNumber ?? 0);
    if (toExpected === 0n) return { verified: false, confirmations: conf, reason: "No USDT Transfer to XNRT wallet" };

    const amountFloat = Number(ethers.formatUnits(toExpected, 18));
    if (typeof opts.minAmount === "number" && amountFloat + 1e-10 < opts.minAmount) {
      return { verified: false, confirmations: conf, reason: `On-chain ${amountFloat} < claimed ${opts.minAmount}` };
    }
    if (conf < need) return { verified: false, confirmations: conf, amountOnChain: amountFloat, reason: `Only ${conf}/${need} confirmations` };

    return { verified: true, confirmations: conf, amountOnChain: amountFloat };
  } catch (e: any) {
    return { verified: false, confirmations: 0, reason: e?.message ?? "Verify error" };
  }
}

5) Routes

server/routes/deposits.ts

import "dotenv/config";
import { Router } from "express";
import { prisma } from "../lib/prisma.js";
import { verifyBscUsdtDeposit } from "../services/verifyBscUsdt.js";

// TODO: wire your real middlewares
const requireAuth = (req: any, res: any, next: any) => req?.user?.id ? next() : res.status(401).json({error:"Unauthorized"});
const requireAdmin = (req: any, res: any, next: any) => req?.user?.isAdmin ? next() : res.status(403).json({error:"Forbidden"});

const r = Router();
const TX_RE = /^0x[a-fA-F0-9]{64}$/;

r.post("/api/transactions/deposit", requireAuth, async (req, res) => {
  const userId = req.user.id as string;
  const { usdtAmount, transactionHash, proofImageUrl } = req.body ?? {};
  if (!TX_RE.test(transactionHash ?? "")) return res.status(400).json({ error: "Invalid tx hash" });
  const amt = Number(usdtAmount);
  if (!amt || amt <= 0) return res.status(400).json({ error: "Invalid amount" });

  const rate = Number(process.env.XNRT_RATE_USDT ?? 100);
  const feeBps = Number(process.env.PLATFORM_FEE_BPS ?? 0);
  const net = amt * (1 - feeBps / 10_000);
  const xnrt = net * rate;

  try {
    const dep = await prisma.deposit.create({
      data: {
        userId,
        network: "BSC",
        asset: "USDT",
        transactionHash,
        toAddress: process.env.XNRT_WALLET!,
        usdtAmount: amt,
        xnrtAmount: xnrt,
        status: "pending",
        verified: false,
        proofImageUrl: proofImageUrl || null,
      },
    });
    res.json(dep);
  } catch (e: any) {
    if (e?.code === "P2002") return res.status(409).json({ error: "TX already submitted" });
    throw e;
  }
});

r.get("/api/admin/deposits/pending", requireAdmin, async (_req, res) => {
  const rows = await prisma.deposit.findMany({
    where: { status: "pending" },
    orderBy: { createdAt: "desc" },
    include: { user: { select: { email: true, username: true } } },
  });
  res.json(rows);
});

r.post("/api/admin/deposits/:id/verify", requireAdmin, async (req, res) => {
  const dep = await prisma.deposit.findUnique({ where: { id: req.params.id } });
  if (!dep) return res.status(404).json({ error: "Not found" });

  const result = await verifyBscUsdtDeposit({
    txHash: dep.transactionHash,
    expectedTo: dep.toAddress,
    minAmount: Number(dep.usdtAmount),
    requiredConf: Number(process.env.BSC_CONFIRMATIONS ?? 12),
  });

  if (result.verified) {
    await prisma.deposit.update({
      where: { id: dep.id },
      data: { verified: true, confirmations: result.confirmations, raw: result as any },
    });
  }
  res.json(result);
});

async function approveAndCredit(depositId: string, notes?: string) {
  return prisma.$transaction(async (tx) => {
    const dep = await tx.deposit.findUnique({ where: { id: depositId }, lock: { mode: "ForUpdate" } });
    if (!dep) throw new Error("Deposit not found");
    if (dep.status !== "pending") return dep;
    if (!dep.verified) throw new Error("Deposit not verified");

    await tx.balance.upsert({
      where: { userId_asset: { userId: dep.userId, asset: "XNRT" } },
      create: { userId: dep.userId, asset: "XNRT", amount: dep.xnrtAmount },
      update: { amount: { increment: dep.xnrtAmount } },
    });

    await tx.trade.create({
      data: {
        userId: dep.userId,
        fromAsset: "USDT",
        toAsset: "XNRT",
        fromAmount: dep.usdtAmount,
        toAmount: dep.xnrtAmount,
        rate: Number(process.env.XNRT_RATE_USDT ?? 100),
        fee: dep.usdtAmount - dep.xnrtAmount / Number(process.env.XNRT_RATE_USDT ?? 100),
        refTx: dep.transactionHash,
      },
    });

    return tx.deposit.update({
      where: { id: dep.id },
      data: { status: "approved", processedAt: new Date(), adminNotes: notes ?? null },
    });
  });
}

r.post("/api/admin/deposits/:id/approve", requireAdmin, async (req, res) => {
  try { res.json(await approveAndCredit(req.params.id, req.body?.notes)); }
  catch (e: any) { res.status(400).json({ error: e?.message ?? "Approve failed" }); }
});

r.post("/api/admin/deposits/:id/reject", requireAdmin, async (req, res) => {
  const updated = await prisma.deposit.update({
    where: { id: req.params.id },
    data: { status: "rejected", adminNotes: req.body?.notes ?? null },
  });
  res.json(updated);
});

r.post("/api/admin/deposits/bulk-approve", requireAdmin, async (req, res) => {
  const ids: string[] = req.body?.depositIds ?? [];
  let approved = 0, failed = 0;
  for (const id of ids) {
    try { await approveAndCredit(id, req.body?.notes); approved++; }
    catch { failed++; }
  }
  res.json({ approved, failed, total: ids.length });
});

r.post("/api/admin/deposits/bulk-reject", requireAdmin, async (req, res) => {
  const ids: string[] = req.body?.depositIds ?? [];
  let rejected = 0, failed = 0;
  for (const id of ids) {
    try { await prisma.deposit.update({ where: { id }, data: { status: "rejected", adminNotes: req.body?.notes ?? null } }); rejected++; }
    catch { failed++; }
  }
  res.json({ rejected, failed, total: ids.length });
});

export default r;

6) Wire routes in server

server/index.ts (or your main)

import "dotenv/config";
import express from "express";
import helmet from "helmet";
import cors from "cors";
import depositsRouter from "./routes/deposits.js";
// plus your auth/session wiring…

const app = express();
app.use(helmet());
app.use(cors());
app.use(express.json({ limit: "2mb" }));

// TODO: app.use(session(...)); app.use(passport.initialize()); app.use(passport.session());
app.use(depositsRouter);

app.get("/healthz", (_req, res) => res.json({ ok: true }));
app.listen(process.env.PORT || 3000, () => console.log("API up"));

🔎 Admin UI wiring you already have

Add a Verify button that calls POST /api/admin/deposits/:id/verify.

Disable Approve until verified=true (allow force-approve with notes if you want).

Bulk approve: send only verified IDs (skip others).

🧪 Acceptance tests

Send 1–5 USDT (BEP-20) to XNRT_WALLET.

User submits txHash + amount in app.

Admin → Verify shows Verified ✅ (12/12 confirmations) after confirmations.

Approve → user balance increases by USDT * 100.

Duplicate tx submit → 409 TX already submitted.

Wrong network/contract/amount → verify returns ❌ with reason.

🛡 Hardening (soon after)

Rate-limit /api/transactions/deposit by IP/user.

Log all admin actions (who approved / rejected).

Daily reconciliation job: sum approved USDT vs on-chain inflows (optional).