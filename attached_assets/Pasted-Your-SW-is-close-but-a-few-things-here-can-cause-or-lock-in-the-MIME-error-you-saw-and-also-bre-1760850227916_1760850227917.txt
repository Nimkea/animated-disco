Your SW is close, but a few things here can **cause or lock-in** the MIME error you saw and also break your update-prompt flow. Here‚Äôs a precise, surgical fix list + drop-in code.

---

## üî• The 4 problematic spots

1. **You skipWaiting immediately**
   You call `self.skipWaiting()` at the top and again during install. That **bypasses** your `onNeedRefresh` update prompt in `main.tsx`‚Äînew SW activates instantly and can mix old HTML with new chunks.

**Fix:** remove the unconditional `skipWaiting`. Only skip when the UI calls it (the `updateSW(true)` flow).

2. **Over-broad precache param ignore**

```ts
precacheAndRoute(self.__WB_MANIFEST, {
  ignoreURLParametersMatching: [/.*/]  // ‚Üê ignores ALL params
});
```

This can mask cache busting and serve the wrong thing.

**Fix:** ignore only analytics params (Workbox default style).

3. **JS/CSS runtime caching matches by extension**
   This will happily cache **whatever 200** comes back‚Äîeven if your server (or SPA fallback) returned **HTML** for a `.js` URL. That **locks in the bad MIME** until you bump caches.

**Fix:** match by `request.destination` (`'script'|'style'`) and add a **content-type guard** plugin so you only cache real JS/CSS.

4. **Catch handler for non-navigations**
   Returning a synthetic 504 text body is okay, but it‚Äôs cleaner to `return Response.error()` so callers get a proper network failure (and nothing gets cached).

---

## ‚úÖ Paste-in patch (key parts only)

Bump your version to invalidate old caches (e.g. `v9`) and apply these edits.

```ts
/// <reference lib="webworker" />
import { cleanupOutdatedCaches, createHandlerBoundToURL, matchPrecache, precacheAndRoute } from 'workbox-precaching';
import { clientsClaim } from 'workbox-core';
import { NavigationRoute, registerRoute, setCatchHandler } from 'workbox-routing';
import { CacheFirst, NetworkFirst, NetworkOnly, StaleWhileRevalidate } from 'workbox-strategies';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';
import { ExpirationPlugin } from 'workbox-expiration';

declare const self: ServiceWorkerGlobalScope;

const CACHE_VERSION = 'v9';
const CACHE_PREFIX = 'xnrt';

// ‚úÖ Keep clientsClaim so the active SW controls open tabs
clientsClaim();

// ‚ùå Remove unconditional skipWaiting ‚Äî let UI decide via message
// self.skipWaiting();

// ---------------- Install: prune only our versioned runtime caches
self.addEventListener('install', (event: ExtendableEvent) => {
  event.waitUntil((async () => {
    const names = await caches.keys();
    await Promise.all(
      names
        .filter(n =>
          n.startsWith(`${CACHE_PREFIX}-`) &&
          !n.endsWith(`-${CACHE_VERSION}`)
        )
        .map(n => caches.delete(n))
    );
    // ‚ùå No skipWaiting here
  })());
});

// ---------------- Precache
precacheAndRoute(self.__WB_MANIFEST, {
  // ‚úÖ Ignore only analytics params (don‚Äôt use /.*/ here)
  ignoreURLParametersMatching: [/^utm_/, /^fbclid$/, /^gclid$/, /^msclkid$/],
});

// ---------------- Activate
self.addEventListener('activate', (event: ExtendableEvent) => {
  event.waitUntil((async () => {
    try { await self.registration.navigationPreload?.enable(); } catch {}
    await cleanupOutdatedCaches(); // Workbox will clean its own precaches
    // Claim now (fine without skipWaiting)
    await self.clients.claim();
  })());
});

// ---------------- SPA navigations
registerRoute(
  new NavigationRoute(createHandlerBoundToURL('/index.html'), {
    denylist: [
      /^\/api\/.*/,
      /\/[^/?]+\.(?:js|css|json|png|jpg|jpeg|svg|gif|webp|ico|map|woff|woff2)$/,
    ],
  })
);

// ---------------- Google Fonts (ok as-is)

// ---------------- JS/CSS runtime: match by destination + type-guard
const onlyIfContentType = (startsWith: string) => ({
  cacheWillUpdate: async ({ response }: { response: Response }) => {
    if (!response || response.status !== 200) return null;
    const ct = response.headers.get('content-type') || '';
    return ct.startsWith(startsWith) ? response : null; // only cache valid type
  },
});

// ‚úÖ Scripts
registerRoute(
  ({ request }) => request.destination === 'script',
  new CacheFirst({
    cacheName: `${CACHE_PREFIX}-scripts-${CACHE_VERSION}`,
    plugins: [
      onlyIfContentType('text/javascript'),
      new CacheableResponsePlugin({ statuses: [0, 200] }),
      new ExpirationPlugin({ maxEntries: 100, maxAgeSeconds: 60 * 60 * 24 * 30 }),
    ],
  })
);

// ‚úÖ Styles
registerRoute(
  ({ request }) => request.destination === 'style',
  new CacheFirst({
    cacheName: `${CACHE_PREFIX}-styles-${CACHE_VERSION}`,
    plugins: [
      onlyIfContentType('text/css'),
      new CacheableResponsePlugin({ statuses: [0, 200] }),
      new ExpirationPlugin({ maxEntries: 60, maxAgeSeconds: 60 * 60 * 24 * 30 }),
    ],
  })
);

// (Optional) If your built assets are fully precached, you can remove the two routes above.

// ---------------- Manifest & icons (ok)

// ---------------- Auth/wallet no-cache (ok)

// ---------------- API NetworkFirst (ok)

// ---------------- Catch handler
setCatchHandler(async ({ request }) => {
  if (request.mode === 'navigate') {
    const shell = await matchPrecache('/index.html');
    if (shell) return shell;
    return new Response('Offline', { status: 503, headers: { 'Content-Type': 'text/plain' } });
  }
  // ‚ùó For non-navigation, surface a proper failure
  return Response.error();
});

// ---------------- Messages: keep SKIP_WAITING trigger for your UI
self.addEventListener('message', (event: ExtendableMessageEvent) => {
  if (event.data?.type === 'SKIP_WAITING') self.skipWaiting();
});

// ---------------- Push (more robust JSON parse)
self.addEventListener('push', (event: PushEvent) => {
  event.waitUntil((async () => {
    let data: any = {};
    try { data = event.data ? event.data.json() : {}; } catch {}
    const { title, body, icon, badge, data: actionData, tag } = data;
    await self.registration.showNotification(title || 'XNRT Notification', {
      body: body || 'You have a new notification',
      icon: icon || '/icon-192.png',
      badge: badge || '/icon-192.png',
      data: actionData,
      tag: tag || 'xnrt-notification',
    });
  })());
});
```

---

## üß™ After you deploy

1. **Bump** `CACHE_VERSION` (`v9` as above).
2. In the browser: **Application ‚Üí Service Workers**

   * Unregister old SW
   * Clear Storage (all)
   * Hard reload
3. Verify a script‚Äôs header:

   ```bash
   curl -I https://xnrt.org/assets/<real-hashed>.js | grep -i content-type
   # ‚Üí text/javascript; charset=utf-8
   ```

---

## Why this prevents the MIME loop

* Matching by **destination** + **content-type guard** means your SW **will not cache** an HTML fallback as a `.js` file.
* Removing unconditional `skipWaiting` ensures the new SW doesn‚Äôt activate mid-session and mix builds; your UI prompts the user, then you call `SKIP_WAITING` deliberately.
* Narrower `ignoreURLParametersMatching` avoids collapsing distinct URLs into one cached entry.

If you want, send your **vite.config.ts** next‚ÄîI‚Äôll confirm the PWA plugin points to this `sw.ts` and that `index.html` is precached correctly.
