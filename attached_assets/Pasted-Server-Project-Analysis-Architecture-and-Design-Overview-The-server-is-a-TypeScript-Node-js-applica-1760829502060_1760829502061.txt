Server Project Analysis
Architecture and Design Overview

The server is a TypeScript/Node.js application built around Express. It uses several services and middleware to provide functionality for user authentication, staking/mining, referral commissions, push notifications and blockchain deposit scanning. Key elements include:

Express server and routing – The index.ts entry point initializes an Express app, applies security middleware (helmet, CORS), logs requests and routes, and mounts API routes. It starts an HTTP server and spawns a retry worker for push notifications and a deposit‑scanner to monitor Binance Smart Chain (BSC) for USDT deposits.

Authentication – The auth module provides registration/login flows with zod validation, password hashing, JWT issuance and CSRF token creation. Middleware guards endpoints via requireAuth, requireAdmin and validateCSRF.

Prisma storage layer – storage.ts wraps Prisma client calls in an IStorage interface and converts Prisma decimal fields into strings. It manages balances, stakes, mining sessions, referral chains, transactions, notifications and activities. It also computes staking and mining rewards and handles referral commissions.

Services – services/hdWallet.ts derives unique BSC deposit addresses for users using a master mnemonic and BIP‑44 path. depositScanner.ts connects to a BSC RPC endpoint and scans Transfer events of the USDT contract to detect deposits to user addresses, crediting XNRT balances once a configurable number of confirmations is reached. email.ts sends verification and password‑reset emails via SMTP. verifyBscUsdt.ts verifies the details of an on‑chain deposit by parsing logs and checking confirmations.

Notifications – notifications.ts creates in‑app notifications in the database and sends push notifications via Web Push (VAPID keys). A retryWorker.ts periodically retries failed push deliveries with exponential back‑off.

Environment validation – validateEnv.ts ensures required environment variables (database connection, session secret, master seed, RPC URL and USDT contract address) are provided and warns when optional values such as SMTP_PASSWORD or AUTO_DEPOSIT are missing.

Noteworthy Implementations
Deposit Address Generation

hdWallet.ts derives deposit addresses from a master BIP‑39 mnemonic. It validates that the mnemonic contains 12–24 words and throws if the MASTER_SEED environment variable is absent or malformed. Private key derivation is supported for sweepers but is explicitly cautioned against exposing to end‑users.

BSC Deposit Scanner

depositScanner.ts periodically scans a range of blocks for USDT transfer events. It uses an explicit 30‑second RPC timeout and disables automatic network detection to improve reliability. Addresses for all users with a depositAddress are collected, and incoming transfers are matched against them. Deposits to the legacy treasury address are also handled for linked wallets. Deposits are written to the transaction table with pending or approved status depending on the number of confirmations,. Auto‑credited deposits update the user’s balance atomically and send a notification. Errors increment an error counter in the scanner state so the service does not silently fail.

Storage Layer and Business Logic

Referral codes and anonymized handles – Referral codes are generated using nanoid to produce a string like XNRTXXXXXXXX. An anonymized handle (Player-ABCD) is computed from a SHA‑256 hash of the user’s ID.

Staking and mining – The storage layer computes daily staking rewards by comparing the lastProfitDate with the current date. It calculates profit as amount * dailyRate and adds it to both the stake’s totalProfit and the user’s stakingBalance, recording an activity and sending a notification. Mining sessions are auto‑completed when now >= endTime, updating XP and XNRT balances, logging an activity and notifying the user.

Referral commissions – Commissions are distributed up to three levels; missing referrers result in a commission credit to a company admin account. Balances are updated, activities recorded and push notifications sent to referrers.

Notification retry – The retry worker uses an exponential backoff schedule and stops retrying after five attempts. Failed subscriptions are disabled to avoid repeated errors.

Issues, Bugs and Potential Improvements
Security and Configuration

Hard‑coded JWT fallback secret – In auth/jwt.ts, the JWT secret falls back to the string 'your-secret-key-change-in-production' when JWT_SECRET is unset. Using a predictable secret compromises the integrity of all tokens. Recommendation: Remove the fallback entirely and throw an error when JWT_SECRET is missing; include JWT_SECRET in validateEnv.ts so the server fails fast if it is not configured.

CSRF token implementation – The CSRF service generates a 32‑byte hex token and validates it by simple equality comparison (code not shown here). Tokens are stored in an in‑memory object keyed by session ID, making them unsuitable for stateless architectures or multi‑instance deployments. Recommendation: Use a proven library such as csurf that stores a token in a signed cookie or incorporate the CSRF token into the session store.

User enumeration risk during registration – The registration endpoint returns different error messages for duplicate email vs. duplicate username ('Email already registered' vs 'Username already taken'). This allows attackers to check whether an email is already registered. Recommendation: Use a uniform error message like “Email or username already in use” to avoid revealing which field caused the conflict.

Password policy and storage – Passwords are hashed with bcrypt, but there is no enforcement of strong password policies beyond a minimum length of eight characters. Recommendation: Enforce complexity requirements (uppercase, numbers, symbols) and implement account lockout after repeated failures in addition to the rate limiter.

Environment validation gaps – validateEnv.ts checks for database URL, session secret, master seed, RPC URL and USDT address, but does not validate other critical secrets such as JWT_SECRET, SMTP_PASSWORD, VAPID_PUBLIC_KEY, VAPID_PRIVATE_KEY or API keys for third‑party services. Recommendation: Add these variables to the validation list and fail startup if any are missing or invalid.

Static SMTP credentials and host – The email service embeds the SMTP host and user name in the code. If the service changes providers, a code update is required. Recommendation: Move all email configuration (host, port, username, from‑address) into environment variables. This also avoids accidentally exposing credentials in source control.

Master seed exposure risk – The master BIP‑39 mnemonic used to derive deposit addresses is loaded from an environment variable and can be retrieved via calls to getDerivedPrivateKey. If the server is compromised or logs the seed, attackers could sweep all user funds. Recommendation: Use a secure secret management solution (e.g., HashiCorp Vault or AWS Secrets Manager) and never log the seed. Restrict access to the private key derivation function to internal sweeper jobs only.

Session fixation concerns – Sessions are stored in a Prisma session table keyed by jwtId. After registration or email verification, the server creates a new session and immediately sets a cookie containing the JWT. However, there is no mechanism to invalidate all previous tokens when a user changes their password or logs out on other devices. Recommendation: Maintain a tokenVersion field on the user and include it in the JWT payload; increment it when sensitive actions occur so that old tokens are rejected.

Code Quality and Performance

Multiple PrismaClient instances – Several modules instantiate their own PrismaClient (e.g., auth/routes.ts and services/depositScanner.ts). Creating many clients can exhaust database connections. Recommendation: Instantiate a single PrismaClient and reuse it across the application, or use Prisma’s recommended global client pattern.

Error handling and logging – The code frequently logs to console but does not use a structured logging framework. Some asynchronous functions catch generic any errors and swallow details. Recommendation: Introduce a logging library like Pino or Winston with log levels and structured JSON output; propagate meaningful error messages to the caller or a central error handler.

Magic numbers and default values – Defaults such as REQUIRED_CONFIRMATIONS (12), XNRT_RATE (100), PLATFORM_FEE_BPS and time constants are hard‑coded in the deposit scanner. Adjusting them requires code changes. Recommendation: Parameterize these values via environment variables with sensible defaults and document them.

Asynchronous race conditions – The deposit scanner uses a boolean flag isScanning to prevent overlapping scans. If the scan takes longer than the one‑minute interval, subsequent scans will be skipped, potentially delaying crediting deposits. A longer scanning range or network latency could exacerbate this. Recommendation: Consider using a queueing system (e.g., BullMQ) or a cron job to handle scanning reliably and adjust the schedule based on scan duration.

Exponential back‑off schedule – The retry worker uses a fixed array of delays, but the delay values are in seconds while lastAttemptAt is compared in milliseconds. This works, but naming variables consistently (e.g., delayInSeconds) and documenting units would improve clarity.

Potential SQL injection with raw queries – The storage.raw method executes arbitrary SQL via queryRawUnsafe. This is powerful but dangerous if user input is passed without sanitization. Recommendation: Avoid using queryRawUnsafe or ensure that any parameters are parameterized.

Missing input validation for deposit scanner configuration – XNRT_RATE, PLATFORM_FEE_BPS and SCAN_BATCH are cast to numbers without checking that they are finite or within expected ranges. Invalid environment values could cause runtime errors or mis‑credit deposits. Recommendation: Parse and validate environment variables before use.

Summary of Recommendations

Secure critical secrets by removing fallback values, validating their presence at startup and storing them in a secret manager.

Strengthen authentication by enforcing password complexity, standardizing error messages to prevent enumeration, rotating JWTs on critical actions and providing a way to revoke all active sessions.

Improve CSRF protection by using a well‑tested middleware that stores tokens in signed cookies and ensures the token is tied to a session.

Centralize configuration by moving SMTP host/credentials, VAPID keys, confirmation thresholds and rate values into environment variables and including them in the environment validator.

Use a single database client and a structured logging framework to improve performance and observability.

Handle asynchronous tasks reliably by using job queues for deposit scanning and push‑notification retries, and by preventing long‑running scans from blocking subsequent runs.

Validate user inputs and environment parameters thoroughly to avoid SQL injection and misconfiguration.

Implementing these improvements will enhance the security, reliability and maintainability of the server.