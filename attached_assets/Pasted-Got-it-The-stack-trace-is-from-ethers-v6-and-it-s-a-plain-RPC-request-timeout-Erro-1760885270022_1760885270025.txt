Got it. The stack trace is from **ethers v6** and it’s a plain **RPC request timeout**:

```
Error: request timeout (code=TIMEOUT, version=6.x)
  at ClientRequest …
  at TLSSocket.emitRequestTimeout …
code: 'TIMEOUT',
shortMessage: 'request timeout'
```

You also log: **“Watching 0 deposit addresses (0 legacy, 0 EVM)”** — so even if the RPC worked, you have nothing to watch right now.

Here’s the decisive fix plan you can apply right away.

# What’s going wrong

1. **RPC endpoint not responding / blocked**

   * Common on Replit when using BSC public nodes on **port 8545** (many hosts throttle or drop).
   * Or your env var is **missing**, so ethers falls back to `http://127.0.0.1:8545` → guaranteed timeout.

2. **Too-large `getLogs` span** on free/public nodes → long queries → timeout.

3. **No addresses loaded** → your watcher is idle; scanner still hits RPC for blocks/logs and times out.

# Do this (copy–paste)

## 1) Use a stable HTTPS:443 RPC and ensure the env var exists

Prefer a 443 endpoint (works best on Replit):

* **BSC Testnet (Chapel)** (free, no key):
  `https://bsc-testnet.publicnode.com`
  or `https://bsc-testnet.public.blastapi.io`

* **BSC Mainnet** (examples):
  `https://bsc.publicnode.com` or a provider with API key (QuickNode/NodeReal/Chainstack) over 443.

Set one secret and read **exactly this name** in code:

```
EVM_RPC_URL=https://bsc-testnet.publicnode.com
```

Double-check at app start:

```ts
const url = process.env.EVM_RPC_URL;
if (!url) throw new Error("Missing EVM_RPC_URL");
console.log("[Scanner] RPC host:", new URL(url).host);
```

If that prints `localhost` or port `8545`, your env isn’t wired.

## 2) Create the provider with a longer timeout + throttling

```ts
import { JsonRpcProvider } from "ethers";

export const provider = new JsonRpcProvider(
  process.env.EVM_RPC_URL!,
  undefined,
  {
    // keep batch small on free nodes
    batchMaxCount: 1,
    // spread calls; many public nodes enforce per-second limits
    throttleLimit: 8,
    throttleSlotInterval: 1000,
    // bump timeout for heavy getLogs
    timeout: 60000,
    // (optional) cacheTimeout: 0,
  }
);

// sanity check early:
await provider.getBlockNumber();
```

## 3) Reduce your `getLogs` chunk size

Most public BSC endpoints time out if you ask for too many blocks/logs.

```ts
const CHUNK = 1000; // 500–1000 is safe on free nodes
for (let from = start; from <= latest; from += CHUNK) {
  const to = Math.min(from + CHUNK - 1, latest);
  const logs = await withRetry(
    () => provider.getLogs({ address: token, fromBlock: from, toBlock: to, topics }),
    `getLogs ${from}-${to}`
  );
  // process logs...
}
```

Retry helper:

```ts
async function withRetry<T>(fn: () => Promise<T>, label: string, retries = 3) {
  let last;
  for (let i = 0; i < retries; i++) {
    try { return await fn(); }
    catch (e: any) {
      last = e;
      const transient = e?.code === "TIMEOUT" || e?.code === "SERVER_ERROR" || e?.code === "NETWORK_ERROR";
      if (!transient || i === retries - 1) throw e;
      const ms = 1000 * (i + 1);
      console.warn(`[Scanner] ${label} failed (${e?.code || e?.shortMessage}); retrying in ${ms}ms`);
      await new Promise(r => setTimeout(r, ms));
    }
  }
  throw last;
}
```

## 4) Actually load/watch some addresses

Right now you’re watching **0** addresses. Seed a test row (or two) so your scanner has something to do and your logs are meaningful.

* If you derive addresses from a MASTER_SEED, confirm the derivation runs and persists rows.
* Log the count at boot:

```ts
console.log(`[DepositScanner] Watching ${addresses.length} deposit addresses`);
```

## 5) Quick smoke tests

* `curl -I $EVM_RPC_URL` in the shell. You should get **HTTP 405/200** with **TLS on port 443** (no 5xx or hang).
* In a tiny script:

  ```ts
  import { JsonRpcProvider } from "ethers";
  const p = new JsonRpcProvider(process.env.EVM_RPC_URL!, undefined, { timeout: 15000 });
  p.getBlockNumber().then(n => console.log("height", n)).catch(console.error);
  ```

  If this times out, the URL or network is the issue (not your scanner).

# Nice-to-have hardening

* Persist `last_scanned_block` and resume; never request from genesis in one shot.
* Add a guard: if `addresses.length === 0`, skip heavy scans and just sleep/poll `getBlockNumber()` to keep the process healthy.
* Consider WS for live deposits if your host allows it:

  ```ts
  // new WebSocketProvider(wssUrl) // watch transfers to addr
  // Fall back to polling when WS drops.
  ```

---

If you paste your current **RPC URL** (mask any key) and the **getLogs** filter you use, I’ll tune the chunk size and topics for your exact token/chain so the timeouts stop completely.
