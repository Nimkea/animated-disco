Server Files Analysis Report

This report provides a comprehensive analysis of the server‑side source code within the XNRT project. Each section summarizes the purpose and functionality of the file or module, identifies notable design decisions, highlights potential issues (security, performance, maintainability), and suggests improvements. Where appropriate, external best‑practice references are cited.

1. Overall Architecture

The server is a TypeScript Express application that exposes a REST API for client interactions, handles authentication, manages user balances and staking/mining features, processes deposits, sends notifications and emails, and interacts with a PostgreSQL database via Prisma and Drizzle. It also integrates with Replit’s OIDC service for optional authentication. The code is modular, with separate folders for authentication (server/auth), services (server/services), storage abstraction (server/storage.ts), route registration (server/routes.ts), environment validation (server/validateEnv.ts) and deployment utilities (server/vite.ts).

2. Database Setup (db.ts)

Purpose: Configures database clients. A Neondatabase/Drizzle pool (db) is used for some queries (e.g., sessions), and a singleton Prisma client (prisma) is used for business logic. The disconnectDatabase function gracefully closes both clients.

Observations:

Uses environment variable DATABASE_URL and throws a descriptive error if missing, which is good for early failure.

Implements a global singleton for prisma in development to avoid connection exhaustion during hot‑reload. This pattern is common in Next.js/Express projects.

Potential Issues & Recommendations:

None critical. Ensure all database interactions are sanitized to avoid SQL injection; Prisma generally provides safety here.

3. Server Entry (index.ts)

Purpose: Bootstraps the Express server. It validates environment variables, configures security middleware, sets CORS policies, logs API calls, registers routes, sets up Vite middleware in development, serves static files in production, starts background workers, and handles graceful shutdown.

Observations:

Security headers: Uses Helmet with CSP policies; disables cross‑origin embedder policy and allows Wasm for development. CSP is set in report‑only mode initially, which can help monitor violations.

CORS: Permits requests from specific localhost domains and production domains; dynamically allows *.replit.dev in development. The callback function warns about rejected origins but still returns false rather than raising errors.

Logging: Wraps res.json to capture JSON responses for API endpoints and truncates logs to 80 characters. Logging responses is useful for debugging but could leak sensitive data (e.g., tokens or financial info). Consider removing response body from logs in production to reduce exposure.

Startup: After registering routes, it starts two background processes: a retry worker for push notifications and a deposit scanner. It listens on the PORT environment variable (default 5000) and binds to 0.0.0.0.

Potential Issues & Recommendations:

Sensitive information in logs: Logging the JSON response may inadvertently expose sensitive data, such as authentication tokens or user balances. Consider logging only the status code and perhaps route, or redacting sensitive fields.

CORS misconfiguration: In development, allowing all *.replit.dev domains may be acceptable. In production, ensure allowedOrigins includes only trusted domains and that credentials: true is set appropriately.

Error handling: The global error handler simply rethrows errors after responding. Re‑throwing will crash the server; remove throw err or log it instead.

4. Notification Service (notifications.ts & retryWorker.ts)

Purpose: Manages in‑app notifications and push notifications via Web Push API. It reads VAPID keys from environment variables, persists notifications using storage, and attempts to send push notifications. A retry worker periodically retries failed notifications with exponential backoff.

Observations:

VAPID keys are parsed from environment variables using string replacements (stripping "publicKey":/"privateKey": prefixes). This implies that keys may be stored in JSON format in the environment – a brittle approach. Consider storing raw keys instead.

The sendPushNotification function fetches subscriptions, constructs a payload and loops through each subscription to send notifications. If a subscription returns 404/410, it calls storage.disablePushSubscription to mark it inactive.

notifyUser creates a notification record, calls sendPushNotification, and updates delivery attempts; it never blocks on failed push sends.

retryWorker.ts polls every 5 minutes, retrieving up to 50 pending notifications and retrying those with exponential backoff. If a user has no active subscriptions, it marks the notification as failed.

Potential Issues & Recommendations:

Environment variable parsing: Don’t embed JSON in environment variables; store raw VAPID keys. Splitting strings using regex could silently produce empty keys and lead to undelivered notifications.

Notification logging: The service logs every push attempt. Consider using a proper logging library with log levels. Optionally, add rate limiting to avoid spamming logs.

Privacy: Be careful not to include personal data in the push payload. Only send necessary information (e.g. type, id) and fetch additional details on the client as needed.

5. Replit OIDC Integration (replitAuth.ts)

Purpose: Integrates Replit’s OIDC login system. It uses openid-client to discover Replit’s configuration, uses passport to manage sessions, and stores session data in PostgreSQL via connect-pg-simple. It also implements a middleware to refresh tokens when expired and to verify user authentication.

Observations:

Requires REPLIT_DOMAINS and REPL_ID environment variables. It discovers OIDC endpoints and caches them for an hour via memoizee.

Defines getSession that returns an Express session configuration with a 1‑week TTL. Sessions are stored in the sessions table.

The upsertUser function creates or updates the user in the database using claims from Replit. It uses referral codes if provided.

In the isAuthenticated middleware, it checks the expires_at property from the user object and refreshes tokens if expired.

Potential Issues & Recommendations:

Session fixation: When refreshing tokens, ensure that the session id is rotated to prevent session fixation attacks.

Error messages: The middleware returns 401 Unauthorized generically. This is acceptable for privacy, but ensure the client handles it gracefully.

6. Retry Worker (retryWorker.ts)

Purpose: Periodically processes pending push notifications with exponential backoff and a maximum retry count.

Observations:

Uses an array of delays (immediate, 5 min, 15 min, 30 min, 60 min) and a global interval of 5 minutes.

Checks whether a notification’s deliveryAttempts exceeds MAX_RETRY_ATTEMPTS and whether enough time has passed since the last attempt.

Logs successes and updates the notification record accordingly.

Potential Issues & Recommendations:

None major. Consider storing retry logic in the database (e.g. next scheduled time) to avoid scanning large numbers of notifications every 5 minutes.

7. Core Routes (routes.ts)

Purpose: Registers all API endpoints. This file is large and covers authentication endpoints, balance and stats, staking, mining, referrals, deposits, wallet linking, tasks, achievements and notifications. It integrates with storage functions, service modules and middleware to enforce auth and CSRF.

Observations:

Rate limiting: Implements rate limiting for push subscription registrations via express-rate-limit. There’s also a login rate limiter in the auth middleware.

Staking: Users can create stakes based on predefined tiers (STAKING_TIERS), process rewards, and withdraw matured stakes. The code ensures the user has enough balance and uses an atomic operation in storage.atomicWithdrawStake to prevent double withdrawals.

Mining: Users start mining sessions for 24 hours, stop them to collect XP and XNRT rewards, and can boost sessions by watching ads. Rewards are stored in user balance and XP. Achievements are unlocked based on mining counts. Rewards are automatically processed by /api/mining/process-rewards.

Referrals: Provides endpoints for referral stats, referral tree, leaderboard and claiming commissions. Commission structures (level 1–3) are computed server‑side.

Deposits: Users can request a USDT deposit address derived from an HD wallet, view deposit history, submit a deposit with proof image or transaction hash, and check on‑chain deposits via verifyBscUsdtDeposit. The platform can also support auto‑deposit scanning via the deposit scanner service.

Wallet linking: Users can link an external EVM wallet by signing a challenge. The server verifies the signature and ensures the wallet isn’t already linked by another user.

Notifications: Users can fetch notifications, mark them read/unread, and manage push subscriptions. Admins can send notifications to arbitrary user IDs.

Admin endpoints: Provide endpoints to fetch total user counts, total deposits, tasks and achievements management, and review pending transactions (deposits/withdrawals).

Potential Issues & Recommendations:

CSRF token validation: The validateCSRFToken function simply compares the header token to the cookie. According to the OWASP CSRF prevention cheat sheet, a more secure approach is to use a double‑submit cookie pattern with a random token that is cryptographically bound to the session, or to place the token in a custom header that cannot be sent by a malicious site
cheatsheetseries.owasp.org
. At minimum, tie the CSRF token to the session id (e.g. store it in the session and compare).

User enumeration: The registration route returns different error messages for duplicate email and username. This allows attackers to enumerate existing emails. The login route also returns “Invalid email or password” but does not differentiate. For both registration and password reset, return a generic “Invalid credentials” message
codesignal.com
.

Hard‑coded constants: Several endpoints use constants for USDT to XNRT conversion (XNRT_RATE_USDT), base mining reward, etc. These should be configurable via environment variables or stored in the database so they can be updated without redeploying.

Deposit verification: The /api/deposit/verify endpoint uses verifyBscUsdtDeposit to check if a transaction has a transfer to the expected address with sufficient confirmations. Ensure that the expectedTo parameter is sanitized (lowercase) and that minAmount matches the current conversion rate. Consider verifying the user’s walletAddress or linking wallet to prevent forging tx hashes.

Push notification rate limit: The pushSubscriptionLimiter allows 10 subscription updates per minute. Attackers could still abuse this to fill the subscription table. Consider adding user id or IP rate limiting and requiring CAPTCHA for repeated attempts.

Pagination: Many GET endpoints (/api/transactions, /api/stakes, /api/mining/history) return unpaginated arrays. For scalability, add query parameters (limit, offset) and corresponding database queries.

8. Services
8.1. Deposit Scanner (services/depositScanner.ts)

Purpose: Monitors the Binance Smart Chain for USDT Transfer events to user deposit addresses and credits the corresponding XNRT amount to the user’s balance. It supports legacy addresses (coin type 714) and new EVM addresses (coin type 60). It runs periodically if AUTO_DEPOSIT=true.

Observations:

Uses ethers.js to connect to the BSC RPC node. Configures a low timeout and disables polling to avoid hanging requests.

Maintains scanner state (last scanned block, error count) in the database. Starts scanning from the current block minus 100 if state doesn’t exist or from BSC_START_FROM=latest if configured.

On each scan, fetches all active deposit addresses and constructs a mapping of address→userId. Queries all Transfer events for the USDT contract between fromBlock and toBlock, then filters events where the to address matches a user deposit address or the treasury address. For each matching event, it creates a transaction record and updates the user’s balance, applying the XNRT_RATE conversion and an optional platform fee.

Updates scanner state after each scan and logs activity.

Potential Issues & Recommendations:

Performance: Fetching all active deposit addresses and scanning through all Transfer events could become slow as the user base grows. Consider caching deposit addresses in memory or splitting scanning into smaller intervals. Use event filters with topics to directly filter by destination addresses (though the BSC API may not support OR filters).

Race conditions: Ensure that deposit crediting is idempotent. The code checks existing transactions by txHash before crediting but also needs to handle chain reorganizations (unlikely on BSC but possible). You may require a few extra confirmations.

Exchange rate: XNRT_RATE_USDT is read from env; ensure it reflects current tokenomics and is updated when exchange rates change.

8.2. Email Service (services/email.ts)

Purpose: Sends verification and password‑reset emails via nodemailer. Includes functions to generate HTML templates and plain text fallback.

Observations:

SMTP credentials (user and host) are hard coded; only the password comes from the environment. Hard‑coding the user can leak sensitive configuration and makes it harder to change. Better to read both username and host from environment variables or a secrets manager.

The email templates are well‑designed and include clear instructions. They embed dynamic links using APP_URL to direct users to verification/reset pages.

Recommendations:

Move SMTP_HOST, SMTP_PORT and SMTP_USER into environment variables. Avoid checking them into source control.

Validate user input in the sendEmail function to prevent header injection (though nodemailer handles most sanitization).

8.3. HD Wallet Service (services/hdWallet.ts)

Purpose: Generates deterministic deposit addresses for users using BIP44 paths and a master mnemonic. Provides utilities to derive addresses with different coin types and to validate master seeds.

Observations:

Relies on MASTER_SEED environment variable and ensures it is a 12/24‑word mnemonic. Uses ethers v6 to derive HD wallets and addresses.

Offers getDerivedPrivateKey, which returns the private key for a derived address. The comment warns not to expose this to users and only use for automated sweeping.

Potential Issues & Recommendations:

Secret storage: The master seed is extremely sensitive; ensure it’s stored securely (e.g. using a secret manager or encrypted environment variables). Never commit it to code.

Private key access: Restrict the getDerivedPrivateKey function to admin scripts. Ensure there are no accidental exports that could leak keys to the API.

Legacy addresses: The service supports old addresses with coin type 714. Plan deprecation or migration strategies; the migration script does this.

9. Storage Abstraction (storage.ts)

Purpose: Encapsulates all database operations using Prisma. Converts Prisma types to domain types, handles decimals as strings, and provides a wide range of CRUD functions for users, balances, stakes, mining sessions, referrals, transactions, tasks, achievements, activities, notifications and push subscriptions.

Observations:

Referral code generation: Uses nanoid to create unique codes (XNRTXXXXXXXX). The generateAnonymizedHandle hashes a user’s id with SHA‑256 to create a pseudonym.

Atomic operations: atomicWithdrawStake ensures a stake can only be withdrawn once by checking its status inside a transaction.

Unpaginated queries: Many functions (e.g. getAllTransactions, getAllUsers) return all results without pagination, which could degrade performance.

Balance and reward calculations: Uses decimals and conversions from Prisma’s Decimal type to strings via helper functions.

Potential Issues & Recommendations:

Pagination: Add support for limit and offset to queries that may return large data sets (users, transactions, notifications, tasks, etc.).

SQL injection: Prisma guards against SQL injection by default, but always validate user inputs before passing them to prisma queries.

Race conditions: The updateBalance and reward functions update balances separately; ensure they run in transactions when updating multiple tables (e.g. updating balance and logging activity).

Referral logic: The code assumes up to three levels of referrals; document this structure clearly in the business requirements.

10. Environment Validation (validateEnv.ts)

Purpose: Validates critical environment variables at startup, printing warnings for optional variables and throwing errors for missing or invalid values.

Observations:

Checks length constraints for SESSION_SECRET and JWT_SECRET and the mnemonic length for MASTER_SEED.

Warns if XNRT_WALLET is not set (defaults to the treasury address) and if AUTO_DEPOSIT is not enabled.

Prints clear error messages and references docs/PRODUCTION_ENV.md when missing variables.

Potential Issues & Recommendations:

Throwing an error stops the server if validation fails, which is intentional. Make sure the deployment pipeline sets all required variables. According to environment variable best practices, secrets should not be hard coded but provided via secure configuration mechanisms
configu.com
.

11. Service Integration & Custom Vite (vite.ts)

Purpose: Sets up the Vite dev server in middleware mode when running in development and serves static files in production. It logs messages using a custom logger and ensures the latest version of index.html is served with a unique query parameter to force refreshes.

Observations:

When vite encounters an error during transformation, the custom logger calls process.exit(1), which will abruptly stop the server. Consider handling errors more gracefully during development.

In production, it serves files from server/public and falls back to index.html for SPA routes.

12. Scripts (scripts/*.ts) & Seed (seed.ts)

Purpose: Provide utilities to generate deposit addresses for existing users (generateDepositAddresses.ts), migrate deposit addresses to a new table (migrateDepositAddresses.ts), and seed initial tasks and achievements (seed.ts).

Observations:

Scripts handle edge cases like existing addresses, multi‑coin support, and derive addresses using hdWallet functions. They print descriptive output to guide operators.

The seeding script inserts tasks and achievements only if the respective tables are empty.

Potential Issues & Recommendations:

Ensure migration scripts are idempotent and run in a development environment before applying in production.

Provide documentation on how to run these scripts safely, including backups and environment variable requirements.

13. Authentication (auth/*.ts)
13.1. CSRF (auth/csrf.ts)

Purpose: Generates CSRF tokens and validates them by checking equality between a header and cookie value.

Issues & Recommendations: This approach is a naive implementation of the double‑submit cookie pattern. OWASP recommends binding the CSRF token to a user’s session (e.g. store it in the session) to prevent tokens being intercepted and reused
cheatsheetseries.owasp.org
.

13.2. JWT (auth/jwt.ts)

Purpose: Signs and verifies JWTs used to authenticate API requests. The payload contains userId, email and a randomly generated jwtId. Tokens expire in 7 days.

Issues & Recommendations:

Expiration and secret are hard coded. Consider reading JWT_EXPIRES_IN from environment variables and rotating secrets periodically. Ensure the secret length meets the required entropy (≥32 chars), which validateEnv.ts checks.

After verifying a JWT, the middleware checks if the session is revoked. This provides token revocation but depends on the session table being maintained (e.g. removal on logout). Ensure sessions are cleaned up to prevent growth.

13.3. Middleware (auth/middleware.ts)

Purpose: Includes requireAuth, requireAdmin, CSRF validation and a login rate limiter. It attaches authenticated user info to the request.

Issues & Recommendations:

The CSRF check uses the naive equality function; improve this by storing the CSRF token in the session and verifying against a secure header.

Login rate limiter only limits based on IP and is disabled in development. Consider rate limiting by email or username to mitigate brute force attacks.

13.4. Password Management (auth/password.ts)

Purpose: Hashes passwords with bcrypt (12 rounds) and compares them. Generates random reset tokens.

Observations: The bcrypt salt rounds (12) provide a reasonable balance between security and performance. When benchmarking on modern CPUs, 10–12 rounds is typical.

13.5. Auth Routes (auth/routes.ts)

Purpose: Handles user registration, login, email verification, password reset requests, password resets and resending verification emails. Uses Zod for input validation.

Issues & Recommendations:

User enumeration: Registration returns specific messages for duplicate email versus username, revealing which field is taken. OWASP recommends generic error messages (“Invalid credentials”) to prevent account enumeration
codesignal.com
.

CSRF for auth: Login and register routes do not use CSRF protection. Although these forms are typically public, consider adding a CSRF token to prevent cross‑site attacks.

Session fixation: On successful login, new JWTs are issued with unique jwtId. Confirm that the old session is revoked to prevent multiple active sessions.

Token reuse: Password reset tokens and email verification tokens are stored in the user table. Ensure they are invalidated after use and expire as intended.

14. Conclusion & Key Recommendations

The XNRT server is a feature‑rich backend that supports staking, mining, referrals, tasks, achievements, wallet linking and deposit management. It follows many good practices, such as environment validation, input validation with Zod, session revocation, JWT usage and rate limiting. Nevertheless, a few areas could be strengthened:

Improve CSRF Protection: The current token comparison mechanism is weak. Use a signed double‑submit cookie pattern or tie the CSRF token to the session, as recommended by OWASP
cheatsheetseries.owasp.org
.

Prevent User Enumeration: Return generic error messages on registration and login to avoid revealing whether an email or username exists
codesignal.com
.

Secure Secrets: Do not embed JSON in environment variables or hard‑code SMTP usernames. Store secrets securely via environment variables or secret managers
configu.com
. Ensure MASTER_SEED and VAPID keys are protected.

Pagination: Add pagination to API endpoints that return lists of data (transactions, users, notifications) to improve performance as the database grows.

Logging & Privacy: Review and sanitize log messages to avoid leaking sensitive user information. Use proper logging libraries with configurable levels.

Environment‑Driven Configuration: Many constants (conversion rates, reward values, mining durations) are hard coded. Move them to environment variables or configuration tables so they can be adjusted without code changes.

Monitoring & Alerts: Add metrics and alerting around deposit scanning, push notifications, and retry worker failure counts to detect issues early.

By implementing these recommendations, the server will be more secure, maintainable and scalable, better serving its users and administrators.