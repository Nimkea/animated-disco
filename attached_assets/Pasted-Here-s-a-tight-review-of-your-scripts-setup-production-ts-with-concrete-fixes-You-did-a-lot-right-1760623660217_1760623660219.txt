Here’s a tight review of your `scripts/setup-production.ts` with concrete fixes. You did a lot right (env-driven password, hashing with bcrypt, creating a balance), but a few things are risky in production and a couple are non-idempotent.

## 🔴 High-risk issues

1. **Password + privilege reset on existing user**

   * If `noahkeaneowen@hotmail.com` already exists, you *overwrite their password* and flip `isAdmin = true`. That’s fine if you intend it, but it’s easy to run by accident.
   * Add an explicit `RESET_ADMIN_PASSWORD=true` flag before updating the password.

2. **Plaintext password printed to logs**

   * `console.log(Password: ${adminPassword})` leaks a production secret into logs. Remove it.

3. **Hard-coded PII**

   * The “wife account” lookup and the “all users” dump output personal info to logs. That’s a privacy foot-gun. Remove these or guard behind a flag and never run by default in prod.

4. **Script can mutate prod with no guard**

   * The filename says “production”, but there’s no explicit guard. Require a `PROD_SETUP_I_UNDERSTAND=1` (or check `NODE_ENV === "production"`) so it can’t run accidentally.

5. **Seeding is not idempotent**

   * You seed achievements and tasks only when the table count is zero. If the table is partially filled, nothing happens; if you rerun after a partial failure you may duplicate rows.
   * Use **upsert by a natural key** (e.g., `title`) so seeds are safe to re-run.

6. **No transaction for multi-step mutations**

   * Creating the admin + balance should be atomic. Wrap in a `$transaction`.

## 🟠 Strongly recommended improvements

* **Use env for admin identity**
  `ADMIN_EMAIL`, `ADMIN_USERNAME` (fallback to defaults), `RESET_ADMIN_PASSWORD`, `PRINT_USERS=false` for optional dumps.
* **Don’t print secrets**
  If you must show a one-time password, print it only when an explicit `SHOW_PASSWORD_ONCE=1` flag is set.
* **Precision for numeric rewards**
  If you move to `@db.Decimal(38, 18)`, seed with numbers or strings (Prisma handles either), that’s fine.
* **Idempotent seeding helpers**
  Upsert by `title` for `Task` and `Achievement`, and keep the arrays as your source of truth.

---

## ✨ Safer, idempotent rewrite (drop-in)

```ts
// scripts/setup-production.ts
import { PrismaClient } from '@prisma/client';
import bcrypt from 'bcrypt';
import { nanoid } from 'nanoid';

const prisma = new PrismaClient();

async function main() {
  console.log('🚀 Production setup starting...\n');

  // ---- hard guard so this can't run by accident ----
  if (process.env.PROD_SETUP_I_UNDERSTAND !== '1') {
    throw new Error('Refusing to run: set PROD_SETUP_I_UNDERSTAND=1 to proceed.');
  }

  const ADMIN_EMAIL = process.env.ADMIN_EMAIL ?? 'noahkeaneowen@hotmail.com';
  const ADMIN_USERNAME = process.env.ADMIN_USERNAME ?? 'noahkeane';
  const ADMIN_PASSWORD = process.env.ADMIN_PASSWORD;
  const RESET_ADMIN_PASSWORD = process.env.RESET_ADMIN_PASSWORD === 'true';
  const PRINT_USERS = process.env.PRINT_USERS === 'true'; // default off for privacy

  if (!ADMIN_PASSWORD) {
    throw new Error('ADMIN_PASSWORD environment variable is required');
  }

  // ------------------ admin & balance ------------------
  console.log('1️⃣ Ensuring admin user exists...');
  const passwordHash = await bcrypt.hash(ADMIN_PASSWORD, 12);
  const referralCode = `ADMIN${nanoid(6).toUpperCase()}`;

  await prisma.$transaction(async (tx) => {
    // upsert admin without exposing password unless explicitly requested
    const existing = await tx.user.findUnique({ where: { email: ADMIN_EMAIL } });

    if (!existing) {
      const admin = await tx.user.create({
        data: {
          email: ADMIN_EMAIL,
          username: ADMIN_USERNAME,
          passwordHash,
          referralCode,
          isAdmin: true,
          xp: 0,
          streak: 0,
          emailVerified: true,
        },
      });

      await tx.balance.upsert({
        where: { userId: admin.id },
        update: {},
        create: {
          userId: admin.id,
          xnrtBalance: 0,
          stakingBalance: 0,
          miningBalance: 0,
          referralBalance: 0,
          totalEarned: 0,
        },
      });

      console.log(`   ✅ Created admin ${ADMIN_EMAIL}`);
    } else {
      // always ensure admin flag; password only if explicitly allowed
      await tx.user.update({
        where: { email: ADMIN_EMAIL },
        data: {
          isAdmin: true,
          ...(RESET_ADMIN_PASSWORD ? { passwordHash } : {}),
        },
      });
      console.log(
        `   ✅ Ensured admin privileges for ${ADMIN_EMAIL}${RESET_ADMIN_PASSWORD ? ' (password reset)' : ''}`,
      );

      await tx.balance.upsert({
        where: { userId: existing.id },
        update: {},
        create: {
          userId: existing.id,
          xnrtBalance: 0,
          stakingBalance: 0,
          miningBalance: 0,
          referralBalance: 0,
          totalEarned: 0,
        },
      });
    }
  });

  // ------------------ achievements (idempotent) ------------------
  console.log('\n2️⃣ Seeding achievements (idempotent upserts)...');
  const achievements = [
    { title: 'First Steps',        description: 'Earn your first 100 XNRT', icon: 'TrendingUp', category: 'earnings', requirement: 100,    xpReward: 50 },
    { title: 'Token Collector',    description: 'Earn 10,000 XNRT',         icon: 'Coins',      category: 'earnings', requirement: 10000,  xpReward: 200 },
    { title: 'Wealth Builder',     description: 'Earn 100,000 XNRT',        icon: 'Trophy',     category: 'earnings', requirement: 100000, xpReward: 500 },
    { title: 'Referral Starter',   description: 'Refer your first friend',  icon: 'UserPlus',   category: 'referrals', requirement: 1,     xpReward: 100 },
    { title: 'Network Builder',    description: 'Refer 10 friends',         icon: 'Users',      category: 'referrals', requirement: 10,    xpReward: 500 },
    { title: 'Streak Beginner',    description: 'Maintain a 7-day streak',  icon: 'Flame',      category: 'streaks',  requirement: 7,     xpReward: 100 },
    { title: 'Dedicated Member',   description: 'Maintain a 30-day streak', icon: 'Award',      category: 'streaks',  requirement: 30,    xpReward: 500 },
  ];

  for (const a of achievements) {
    await prisma.achievement.upsert({
      where: { title: a.title }, // requires UNIQUE(title) in schema for best guarantees
      update: { ...a },
      create: { ...a },
    });
  }
  console.log(`   ✅ Upserted ${achievements.length} achievements`);

  // ------------------ tasks (idempotent) ------------------
  console.log('\n3️⃣ Seeding tasks (idempotent upserts)...');
  const tasks = [
    { title: 'Daily Login Bonus',    description: 'Log in to the platform',                         category: 'daily',   xnrtReward: 10,  xpReward: 5 },
    { title: 'Share on Social Media',description: 'Share XNRT on your favorite social platform',   category: 'social',  xnrtReward: 50,  xpReward: 25 },
    { title: 'Complete Your Profile',description: 'Add your profile information',                  category: 'profile', xnrtReward: 100, xpReward: 50 },
    { title: 'First Stake',          description: 'Make your first stake',                         category: 'staking', xnrtReward: 200, xpReward: 100 },
    { title: 'Mining Session',       description: 'Complete a mining session',                     category: 'mining',  xnrtReward: 50,  xpReward: 25 },
  ];

  for (const t of tasks) {
    await prisma.task.upsert({
      where: { title: t.title }, // add UNIQUE(title) in schema if you haven’t
      update: { ...t },
      create: { ...t },
    });
  }
  console.log(`   ✅ Upserted ${tasks.length} tasks`);

  // ------------------ optional: user list (off by default) ------------------
  if (PRINT_USERS) {
    console.log('\n👥 Current users (privacy-guarded output enabled):');
    const users = await prisma.user.findMany({
      select: { email: true, username: true, isAdmin: true, referralCode: true, createdAt: true },
      orderBy: { createdAt: 'desc' },
    });
    users.forEach((u, i) =>
      console.log(`   ${i + 1}. ${u.isAdmin ? '👑 ADMIN' : '👤 USER'} - ${u.email} (@${u.username}) | ${u.referralCode} | ${u.createdAt.toISOString()}`),
    );
    console.log(`   📊 Total users: ${users.length}`);
  }

  console.log('\n✨ Production setup complete.');
}

main()
  .catch((err) => {
    console.error('❌ Error setting up production:', err);
    process.exitCode = 1;
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
```

### Notes about the rewrite

* **Guards & flags**: prevents accidental runs, protects secrets, and keeps PII out of logs by default.
* **Atomic** admin creation/balance creation via `$transaction`.
* **Idempotent** seeding via `upsert` (add `@unique` on `Achievement.title` and `Task.title` in your schema for stronger guarantees).
* **No plaintext password in logs**; password reset only when explicitly requested.

---

## Optional schema tweaks to support this

Add uniques for safe upserts:

```prisma
model Achievement {
  id          String   @id @default(uuid())
  title       String   @unique
  // ...
}

model Task {
  id          String   @id @default(uuid())
  title       String   @unique
  // ...
}
```

(And consider the Decimal precision & the `transactionHash` -> `@db.Text` change we discussed earlier.)

---

If you want, I can tailor the script to your exact logging platform (e.g., redact in structured logs), or add a one-time admin invite flow instead of password resets.
