Awesome—here’s a crisp, actionable plan based on the Replit agent’s notes plus concrete patches you can drop in now.

What I’ll fix (summary)

Prisma field mismatches (runtime errors)

detectedAt → createdAt (UnmatchedDeposit)

reportedAt → createdAt (DepositReport)

report.transactionHash → report.txHash

Remove writes to resolvedBy (field doesn’t exist in DepositReport)

Guard report.amount (nullable)

CORS (prod)

Allow-list multiple origins (e.g., xnrt.org and www.xnrt.org), not a single string.

Cookie clearing (WebView-friendly)

Clear sid with the same attributes used to set it (secure/sameSite).

Cosmetics

Prefix unused req params with _ to silence TS.

Patches
A) server/routes.ts — fix Prisma field names & null guards
diff --git a/server/routes.ts b/server/routes.ts
--- a/server/routes.ts
+++ b/server/routes.ts
@@
-  app.get('/api/admin/unmatched-deposits', requireAuth, requireAdmin, async (req, res) => {
+  app.get('/api/admin/unmatched-deposits', requireAuth, requireAdmin, async (_req, res) => {
     try {
       const unmatched = await prisma.unmatchedDeposit.findMany({
         where: { matched: false },
-        orderBy: { detectedAt: 'desc' },
+        // schema has no detectedAt; use createdAt
+        orderBy: { createdAt: 'desc' },
         take: 100
       });
       res.json(unmatched);
     } catch (error) {
       console.error("Error fetching unmatched deposits:", error);
       res.status(500).json({ message: "Failed to fetch unmatched deposits" });
     }
   });
@@
-  app.get('/api/admin/deposit-reports', requireAuth, requireAdmin, async (req, res) => {
+  app.get('/api/admin/deposit-reports', requireAuth, requireAdmin, async (_req, res) => {
     try {
       const reports = await prisma.depositReport.findMany({
-        where: { status: 'pending' },
+        // reports created as 'open' by default
+        where: { status: 'open' },
         include: {
           user: {
             select: { email: true, username: true }
           }
         },
-        orderBy: { reportedAt: 'desc' },
+        // schema has createdAt, not reportedAt
+        orderBy: { createdAt: 'desc' },
         take: 100
       });
       res.json(reports);
     } catch (error) {
       console.error("Error fetching deposit reports:", error);
       res.status(500).json({ message: "Failed to fetch deposit reports" });
     }
   });
@@
   app.post('/api/admin/deposit-reports/:id/resolve', requireAuth, requireAdmin, validateCSRF, async (req, res) => {
     try {
       const { id } = req.params;
       const { resolution, adminNotes } = req.body;
@@
-      if (report.status !== 'pending') {
+      if (report.status !== 'open') {
         return res.status(400).json({ message: "Report already resolved" });
       }
 
       if (resolution === 'approved') {
         // Credit user with reported amount
-        const xnrtRate = Number(process.env.XNRT_RATE_USDT || 100);
-        const platformFeeBps = Number(process.env.PLATFORM_FEE_BPS || 0);
-        const usdtAmount = parseFloat(report.amount.toString());
+        if (report.amount == null) {
+          return res.status(400).json({ message: "Report has no amount to approve" });
+        }
+        const xnrtRate = Number(process.env.XNRT_RATE_USDT || 100);
+        const platformFeeBps = Number(process.env.PLATFORM_FEE_BPS || 0);
+        const usdtAmount = parseFloat(report.amount.toString());
         const netUsdt = usdtAmount * (1 - platformFeeBps / 10_000);
         const xnrtAmount = netUsdt * xnrtRate;
 
         await prisma.$transaction(async (tx) => {
           // Create approved transaction
           await tx.transaction.create({
             data: {
               userId: report.userId,
               type: "deposit",
               amount: new Prisma.Decimal(xnrtAmount),
               usdtAmount: new Prisma.Decimal(usdtAmount),
-              transactionHash: report.transactionHash,
+              // schema field is txHash (nullable); copy into Transaction.transactionHash
+              transactionHash: report.txHash ?? undefined,
               status: "approved",
               adminNotes: adminNotes || "Credited from deposit report",
               approvedBy: req.authUser!.id,
               approvedAt: new Date(),
             }
           });
@@
           // Update report status
           await tx.depositReport.update({
             where: { id },
             data: {
-              status: 'approved',
-              resolvedBy: req.authUser!.id,
+              status: 'approved',
               resolvedAt: new Date(),
               adminNotes: adminNotes || null,
             }
           });
         });
       } else {
         // Reject report
         await prisma.depositReport.update({
           where: { id },
           data: {
             status: 'rejected',
-            resolvedBy: req.authUser!.id,
             resolvedAt: new Date(),
             adminNotes: adminNotes || null,
           }
         });
       }


Notes:
• DepositReport has no resolvedBy; removed those writes.
• DepositReport status flow uses 'open' | 'approved' | 'rejected'.
• report.amount can be null; guarded.
• txHash is the correct field on DepositReport.

(If you later want to track the resolver, add a resolvedBy String? field to DepositReport in Prisma and re-introduce those writes.)

B) server/index.ts — CORS allow-list + match real origins
diff --git a/server/index.ts b/server/index.ts
--- a/server/index.ts
+++ b/server/index.ts
@@
-// CORS configuration
-const CLIENT_URL = process.env.CLIENT_URL || 'http://localhost:5000';
-app.use(cors({
-  origin: CLIENT_URL,
-  credentials: true,
-}));
+// CORS configuration (allow-list)
+const rawOrigins = (process.env.CORS_ORIGINS || process.env.CLIENT_URL || 'http://localhost:5000')
+  .split(',')
+  .map(s => s.trim())
+  .filter(Boolean);
+
+app.use(cors({
+  origin(origin, cb) {
+    // allow REST tools / curl / same-origin / mobile webview with null Origin
+    if (!origin) return cb(null, true);
+    if (rawOrigins.includes(origin)) return cb(null, true);
+    // also allow matching base domains (e.g., with/without www)
+    try {
+      const u = new URL(origin);
+      const bare = `${u.protocol}//${u.hostname}`;
+      if (rawOrigins.some(o => o.includes(u.hostname) || o === bare)) {
+        return cb(null, true);
+      }
+    } catch {}
+    return cb(new Error(`CORS blocked: ${origin}`));
+  },
+  credentials: true,
+}));


Set CORS_ORIGINS like:
CORS_ORIGINS=https://xnrt.org,https://www.xnrt.org,https://app.xnrt.org

C) server/auth/routes.ts — clear cookie with matching attributes
diff --git a/server/auth/routes.ts b/server/auth/routes.ts
--- a/server/auth/routes.ts
+++ b/server/auth/routes.ts
@@
 router.post('/logout', requireAuth, async (req, res) => {
   try {
     const jwtId = req.authUser?.jwtId;
@@
-    // Clear cookie
-    res.clearCookie('sid');
+    // Clear cookie using the same attributes used when setting it
+    const isProd = process.env.NODE_ENV === 'production';
+    res.clearCookie('sid', {
+      httpOnly: true,
+      secure: isProd,
+      sameSite: isProd ? 'none' : 'lax',
+      path: '/',
+    });
     res.status(204).send();
   } catch (error) {
     console.error('Logout error:', error);
     res.status(500).json({ message: 'Internal server error' });
   }
 });

D) Minor TS cleanups (silence unused req)

You’ll see I already changed a few handlers from (req, res) → (_req, res) above. Apply similarly wherever your LSP flagged:

lines: 31, 148, 300, 476, 1437, 1487, 1497, 1817, 1916, 2025, 2154, 2210, 2365, 2415, 2567, 2721, etc.

(Only prefix with _ when genuinely unused.)

Environment reminders

Set both:

CORS_ORIGINS (comma list)

CLIENT_URL (your primary app origin, used elsewhere)

Cookies: you’re already using sameSite: 'none' + secure: true in prod for sid and csrfToken—keep that.