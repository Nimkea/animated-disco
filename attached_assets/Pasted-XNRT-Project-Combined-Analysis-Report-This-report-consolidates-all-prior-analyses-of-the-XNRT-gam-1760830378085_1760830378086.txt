XNRT Project – Combined Analysis Report

This report consolidates all prior analyses of the XNRT gamification platform. The project is a full‑stack monorepo consisting of a React/Vite client PWA, an Express/Prisma server, shared TypeScript schemas and configuration files. Each layer was examined—root‑level configuration, backend services, frontend code and public assets. The strengths, weaknesses and recommended improvements are summarised here.

1 Overall Architecture and Strengths

The XNRT project follows a modern, modular architecture:

Full TypeScript stack: client, server and shared types use TypeScript, enabling end‑to‑end type safety.

Shared schemas: Zod schemas in the shared folder keep API requests and responses consistent.

Modular server design: the server separates authentication, business logic (staking, mining, referrals), services (HD wallet derivation, deposit scanning, email, push notifications) and data access via a storage.ts abstraction.

Modern client: the PWA leverages React 18, Vite, Radix/shadcn UI components and React Query. It includes features like a sidebar, a chatbot, staking/mining dashboards, referral leaderboards and a rich admin console.

Environment validation: the server checks for critical variables at startup and aborts on missing values.

Security features: the server uses Helmet for HTTP headers, CSRF tokens for state‑changing requests, rate limiting on login and email‑reset routes, and JWT‑based sessions. The client uses secure cookies and fetch wrappers to attach CSRF tokens.

These elements make for a professional, maintainable codebase. However, several issues undermine its robustness and security.

2 Root‑Level Configuration

The top‑level files define the build and development environment:

.gitignore / .replit / tailwind / PostCSS / tsconfig: these are well configured, hiding sensitive files, configuring Replit port mappings, customizing Tailwind and enabling strict TypeScript.

vite.config.ts: splits vendor bundles and loads PWA plugins. It uses top‑level await to import Replit plugins; if Node or bundlers do not support it, wrap the config in an async function or move dynamic imports inside a plugin. Bundle split lists must be maintained when new libraries are added
screenshot
.

Environment variables: root files require DATABASE_URL and other variables, but some critical secrets (JWT secret, SMTP user/password, VAPID keys) are not validated at startup. Always validate all required variables.

Documentation: replit.md provides a useful overview. Keep it updated and cross‑link to environment configuration.

3 Server Code Analysis

The server implements core business logic and exposes a REST API:

Authentication: registration/login uses hashed passwords, CSRF tokens and JWTs. However, fallback values for JWT_SECRET degrade security; remove defaults and enforce presence of secrets. Registration returns different messages for duplicate email vs username, enabling account enumeration—use a generic error message.

Storage layer: wraps Prisma queries and implements staking, mining and referral logic. It calculates profits, logs activities and distributes commissions. Yet each module instantiates its own PrismaClient, risking connection exhaustion. Adopt a singleton client across modules.

Deposit scanner: uses ethers.js to monitor BSC for USDT transfers. It credits deposits after a configurable number of confirmations and updates user balances. Multiple scanner instances could run concurrently (if the app scales horizontally), causing double processing. Use distributed locks or a job queue. Configurable parameters (confirmations, block range, conversion rate) are hard‑coded—move them into environment variables.

Services: derive HD wallets from a master seed and verify on‑chain transfers. The master seed is a highly sensitive secret; store it in a secret manager and restrict private key derivation to internal jobs.

Notifications: create in‑app notifications and push messages with a retry worker. The retry schedule is fixed; using a queue library (e.g., BullMQ) could simplify retry logic.

CSRF protection: tokens are compared by equality and stored in memory, which is fragile in multi‑instance deployments. Adopt a library like csurf or implement double‑submit cookies
cheatsheetseries.owasp.org
.

Key server issues and fixes

Hard‑coded secrets: Remove fallback JWT secrets and default values for sensitive keys. Validate all secrets at startup and load them from environment variables or secret managers.

User enumeration: Standardise error messages for login and registration to avoid exposing whether an email or username exists.

Password policy: Enforce strong password rules and account lockout. Hash verification and reset tokens before storing; purge expired tokens regularly.

Singleton Prisma client: Create a global PrismaClient instance and reuse it to prevent connection exhaustion.

Distributed locks: Use a database advisory lock or a queue for deposit scanning to avoid duplicate crediting.

Comprehensive environment validation: Add JWT secrets, SMTP credentials and VAPID keys to validateEnv.ts to fail fast on missing configuration.

Logging and error handling: Replace console.log with a structured logger and bubble up meaningful errors.

4 Public Assets (Icons and Manifest)

The public/ directory contains icons and favicons for the PWA. Analysis revealed several problems:

Non‑square images: Many icons are non‑square screenshots (e.g., 192×120, 512×321), whereas PWA icons must be square (192×192 and 512×512 minimum)
favicon.im
. The images are full login screenshots, which become illegible when scaled down.

Missing manifest: No manifest.json is present. Browsers use the manifest to discover icons and metadata. Without it, the PWA cannot install properly.

Favicons: The .ico file contains non‑standard sizes and only one resolution. A proper multi‑size ICO should embed 16×16 and 32×32 images
favicon.im
.

Maskable icons: For Android adaptive icons, a maskable icon must be provided and declared in the manifest. The existing icon‑512‑maskable.png is a screenshot and will be cropped poorly.

Icon improvement plan

Design a high‑resolution logo (e.g., 1024×1024) containing only the brand symbol; use it to export 16×16, 32×32, 180×180, 192×192, 256×256, 384×384 and 512×512 square PNGs
favicon.im
.

Create a multi‑size favicon.ico including 16×16 and 32×32 images; keep file sizes small (4 KB for 192×192, 15 KB for 512×512)
favicon.im
.

Add manifest.json: define app name, start URL, display mode, theme colours and icon entries. Specify both normal and maskable icons and reference the new PNGs
docs.expo.dev
.

Test on various platforms: confirm that icons display correctly in browser tabs, home‑screen shortcuts, splash screens and adaptive icon masks.

5 Client Application Analysis

The front‑end is a feature‑rich PWA written in React. Key elements include pages for staking, mining, deposits, withdrawals, referrals, achievements and an extensive admin console. Custom hooks and UI components provide context management, toasts, confetti animations, theme toggles and PWA prompts. Issues identified during the deep analysis:

CSRF handling: The client fetches a CSRF token and stores it on window.CSRF_TOKEN. Storing tokens on the global window exposes them to XSS. Use a double‑submit cookie pattern or secure cookies
cheatsheetseries.owasp.org
.

Toast duration bug: The toast hook sets TOAST_REMOVE_DELAY to ~16 min, causing notifications to linger. Reduce this to ~5 s to improve UX.

Hard‑coded constants: Conversion rate (USDT_TO_XNRT_RATE = 100) and company wallet address appear in several files. These values should be served by the backend or configuration to avoid drift.

Inconsistent error handling: Many fetch calls assume success and rarely catch exceptions. Always wrap network calls in try/catch, display error toasts and handle unauthorised responses centrally.

User enumeration in forms: Registration forms display different messages for duplicate email vs username—mirroring the server issue. Use a generic error and validate inputs.

Password strength: Registration lacks password strength indicators or complexity requirements. Implement the password-strength component and enforce strong passwords.

Base64 file uploads: Deposit proof images are converted to Base64 before sending, increasing payload size by ~33 %
celerdata.com
. Use FormData to upload files as multipart.

PWA icons mismatch: The client references icon-192.png (a non‑square screenshot) as the logo in the sidebar. Replace with the newly designed square icon and update references across components.

Automatic state‑changing calls: The staking page calls /api/stakes/process-rewards on mount, which triggers backend mutations. Avoid state‑changing API calls on page load; require explicit user action or schedule via cron.

Mixed mobile detection: The wallet linking code uses a regex to detect mobile browsers and instructs users to open MetaMask. Server‑side detection or a library such as ua-parser-js may provide more accurate results.

Missing CSRF on auth forms: Login and registration requests are sent without CSRF headers. Even with SameSite cookies, sending a CSRF header for all state‑changing requests is recommended
cheatsheetseries.owasp.org
.

Admin console

The admin dashboard is a rich Single‑Page Application that lets administrators manage deposits, withdrawals, users, stakes, tasks, achievements, analytics and settings. Features such as search, filters, bulk approval/rejection and real‑time statistics are implemented. Key considerations:

Bulk actions safety: Ensure server‑side validation to prevent race conditions when approving or rejecting multiple requests.

Hard‑coded wallet address in UI: The admin deposit page displays a hard‑coded company wallet. Pull this from configuration or the API.

Verification thresholds: The “Verify” button should respect confirmation thresholds and warn admins if the deposit has fewer than the required number of confirmations.

Pagination: When dealing with large datasets (e.g., thousands of users), implement server‑side pagination to avoid heavy client rendering.

6 Combined Recommendations

Bringing together all findings from the root, server, client and public analyses, the following improvements are recommended:

Secret management and configuration

Remove fallback values for sensitive secrets (JWT secret, VAPID keys); enforce environment variables at startup.

Store secrets in a secure vault or environment and avoid hard‑coding wallet addresses and conversion rates.

Validate all environment variables (database URL, SMTP host/user/pass, master seed, RPC URL, confirmation thresholds) before boot.

Database and concurrency

Use a singleton PrismaClient to avoid connection exhaustion.

Introduce distributed locking or job queues for the deposit scanner and retry worker to prevent concurrent executions across instances.

Authentication and CSRF

Enforce strong password policies and consistent error messages to prevent enumeration
codesignal.com
.

Implement a token versioning mechanism to revoke old JWTs on password change or logout.

Adopt a robust CSRF solution (double‑submit cookies or csurf) and include CSRF headers on all mutating requests
cheatsheetseries.owasp.org
.

User‑facing improvements

Replace the PWA icons with square, logo‑only images and add a manifest.json that declares multiple icon sizes and maskable variants
favicon.im
.

Lower toast durations and improve error handling on network calls.

Remove automatic state‑changing calls on page mount; allow users to trigger reward processing or run these tasks via scheduled jobs.

Use multipart/form‑data for file uploads to avoid Base64 overhead
celerdata.com
.

Centralise configuration such as conversion rates and addresses in the backend; the client should fetch these values instead of hard‑coding them.

Administrative tools

Validate inputs for admin actions and ensure server‑side checks when performing bulk approvals or rejections.

Paginate large datasets and add filters to reduce client load.

Log admin activities and use role‑based access control to protect sensitive endpoints.

Testing and monitoring

Add unit and integration tests for deposit scanning, staking/mining rewards and referral logic.

Use structured logging (e.g., Pino) and integrate with monitoring tools (e.g., Sentry) to capture errors and performance metrics.

Regularly audit dependencies with tools like npm audit and update outdated packages.

7 Conclusion

The XNRT project exhibits a solid foundation with modern tools, type safety and modular design. However, critical improvements are needed before production deployment. Strengthening secret management, centralising configuration, locking down authentication flows, improving CSRF handling, designing proper PWA assets and enforcing good user‑experience patterns will harden the system against common web threats and ensure a polished front‑end. By addressing the issues summarised above and following the proposed recommendations, the platform will be more secure, maintainable and user‑friendly.