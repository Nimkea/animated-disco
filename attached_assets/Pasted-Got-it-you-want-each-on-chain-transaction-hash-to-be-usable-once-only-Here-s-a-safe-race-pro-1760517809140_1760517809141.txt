Got it — you want each on-chain transaction hash to be usable **once** only. Here’s a safe, race-proof way to enforce it:

# 1) Make `transactionHash` unique in the DB

EVM tx hashes are 66 chars (`0x` + 64 hex). Add a unique constraint so the database rejects duplicates even under race conditions.

**schema.prisma**

```prisma
model Transaction {
  id               String   @id @default(uuid())
  userId           String
  type             String
  amount           Decimal
  usdtAmount       Decimal?
  source           String?
  walletAddress    String?
  transactionHash  String?  @unique @db.VarChar(66) // <- enforce one-time use
  proofImageUrl    String?
  status           String   @default("pending")
  adminNotes       String?
  fee              Decimal?
  netAmount        Decimal?
  approvedBy       String?
  approvedAt       DateTime?
  verified         Boolean  @default(false)
  confirmations    Int      @default(0)
  verificationData Json?
  createdAt        DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([type])
  @@index([status])
}
```

Then run:

```bash
npx prisma db push
npx prisma generate
```

> Note: PostgreSQL allows multiple NULLs on a UNIQUE column, so old rows without a hash are fine; any non-null `transactionHash` must be unique across all transactions.

# 2) Normalize + pre-check on API (nice UX)

Reject duplicates before hitting the UNIQUE constraint, and still be safe if two requests race.

**server/routes.ts** (deposit endpoint)

```ts
app.post('/api/transactions/deposit', requireAuth, validateCSRF, async (req, res) => {
  try {
    const userId = req.authUser!.id;
    let { usdtAmount, transactionHash, proofImageUrl } = req.body;

    if (!usdtAmount || !transactionHash) {
      return res.status(400).json({ message: "Missing required fields" });
    }

    // Normalize & validate hash
    transactionHash = String(transactionHash).trim().toLowerCase();
    if (!/^0x[0-9a-f]{64}$/.test(transactionHash)) {
      return res.status(400).json({ message: "Invalid transaction hash" });
    }

    // Optional: normalize proof URL check kept as-is
    if (proofImageUrl) {
      const isBase64 = proofImageUrl.startsWith('data:image/');
      const isUrl = /^https?:\/\//i.test(proofImageUrl);
      if (!isBase64 && !isUrl) {
        return res.status(400).json({ message: "Invalid proof image URL format" });
      }
    }

    // Soft duplicate check (good UX)
    const existing = await prisma.transaction.findFirst({
      where: { transactionHash }
    });
    if (existing) {
      return res.status(409).json({
        message: "This transaction hash was already used for a deposit."
      });
    }

    const xnrtAmount = parseFloat(usdtAmount) * 100;

    const tx = await prisma.transaction.create({
      data: {
        userId,
        type: "deposit",
        amount: new Prisma.Decimal(xnrtAmount),
        usdtAmount: new Prisma.Decimal(usdtAmount),
        transactionHash,
        proofImageUrl: proofImageUrl ?? null,
        status: "pending",
        verified: false,
        confirmations: 0
      }
    });

    res.json(tx);
  } catch (error: any) {
    // Hard guarantee in case of racing requests
    if (error.code === 'P2002' && error.meta?.target?.includes('transactionHash')) {
      return res.status(409).json({
        message: "This transaction hash was already used for a deposit."
      });
    }
    console.error("Error creating deposit:", error);
    res.status(500).json({ message: "Failed to create deposit" });
  }
});
```

# 3) Always store + compare hashes in lowercase

Anywhere you touch the hash (verification, admin actions), normalize:

```ts
const hash = deposit.transactionHash!.toLowerCase();
```

---

That’s it. With the DB **UNIQUE** constraint + API pre-check + normalization, a single blockchain tx can only ever create **one** deposit — no repeats, even under concurrent requests.
