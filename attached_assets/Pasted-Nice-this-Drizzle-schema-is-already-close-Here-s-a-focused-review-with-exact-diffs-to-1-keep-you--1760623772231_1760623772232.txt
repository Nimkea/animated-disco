Nice—this Drizzle schema is already close. Here’s a focused review with exact diffs to (1) keep you unblocked, (2) harden data integrity, and (3) avoid future drift.

---

## ✅ Good

* `Transaction.transactionHash` and `walletAddress` are `text` already (safe vs the varchar(66) error you hit).
* Sensible indexes on foreign keys and status fields.
* `verificationData` is `jsonb` (good).

---

## 🔴 Important fixes

### 1) Don’t let the old shrinking migration run

Your current schema is `text`, but you likely still have a queued migration that tries to set `varchar(66)`. Delete/regenerate that migration so the next publish doesn’t attempt the shrink.

### 2) Precision for token amounts

You’re using `decimal(..., { precision: 18, scale: 2 })` in balances, transactions, stakes, etc. For token math (18 decimals), you’ll lose precision.

**Change to 38,18 everywhere you store token amounts:**

```ts
// examples
xnrtBalance: decimal("xnrtBalance", { precision: 38, scale: 18 }).default("0").notNull(),
amount:      decimal("amount",      { precision: 38, scale: 18 }).notNull(),
usdtAmount:  decimal("usdtAmount",  { precision: 38, scale: 18 }),
fee:         decimal("fee",         { precision: 38, scale: 18 }),
netAmount:   decimal("netAmount",   { precision: 38, scale: 18 }),
totalProfit: decimal("totalProfit", { precision: 38, scale: 18 }).default("0").notNull(),
dailyRate:   decimal("dailyRate",   { precision: 8, scale: 6 }).notNull(), // if you want finer %, e.g. 0.012345
```

(If you truly only want 2 decimals, keep as-is—but that’s unusual for crypto.)

### 3) Add uniqueness where the app assumes it

* **One row per (user, task):**

```ts
export const userTasks = pgTable("UserTask", { /* ... */ }, (table) => [
  index("user_tasks_userId_idx").on(table.userId),
  index("user_tasks_taskId_idx").on(table.taskId),
  unique("user_tasks_user_task_unique").on(table.userId, table.taskId),
]);
```

* **No duplicate tx hashes (when present):**

```ts
export const transactions = pgTable("Transaction", { /* ... */ }, (table) => [
  index("transactions_userId_idx").on(table.userId),
  index("transactions_type_idx").on(table.type),
  index("transactions_status_idx").on(table.status),
  unique("transactions_txhash_unique").on(table.transactionHash),
  index("transactions_wallet_idx").on(table.walletAddress),
]);
```

* **Upsert-friendly titles (if you seed by title):**

```ts
export const tasks = pgTable("Task", { /* ... */ }, (table) => [
  unique("tasks_title_unique").on(table.title),
]);
export const achievements = pgTable("Achievement", { /* ... */ }, (table) => [
  unique("achievements_title_unique").on(table.title),
]);
```

* **Referrals** (avoid duplicates). Pick one rule:

```ts
// Either only one referrer per referred user:
unique("referrals_referred_unique").on(referrals.referredUserId)
// or only one row per (referrer, referred, level):
unique("referrals_pair_level_unique").on(referrals.referrerId, referrals.referredUserId, referrals.level)
```

### 4) Auto-update timestamps

`updatedAt` columns won’t update automatically with `.defaultNow()` alone.

```ts
updatedAt: timestamp("updatedAt").defaultNow().$onUpdate(() => sql`now()`).notNull(),
```

Apply to `users`, `balances`, `pushSubscriptions`, etc.

---

## 🛡️ Data-quality hardening (optional but recommended)

### 5) Enums instead of free-form strings

Prevent typos and ease querying.

```ts
import { pgEnum } from "drizzle-orm/pg-core";

export const transactionType = pgEnum("transaction_type", ["deposit", "withdrawal"]);
export const transactionStatus = pgEnum("transaction_status", ["pending","approved","rejected","paid"]);
export const stakeStatus = pgEnum("stake_status", ["active","completed","withdrawn"]);
export const taskCategory = pgEnum("task_category", ["daily","weekly","special","social","profile","staking","mining"]);

export const transactions = pgTable("Transaction", {
  // ...
  type:   transactionType("type").notNull(),
  status: transactionStatus("status").default("pending").notNull(),
  // ...
});

export const stakes = pgTable("Stake", {
  // ...
  status: stakeStatus("status").default("active").notNull(),
});

export const tasks = pgTable("Task", {
  // ...
  category: taskCategory("category").notNull(),
});
```

### 6) JSON for metadata fields

You’re storing `metadata` as `varchar` in `activities` and `notifications`. Make it `jsonb` for structured data.

```ts
metadata: jsonb("metadata"), // in both tables
```

### 7) (Optional) Regex checks for EVM values (DB-level)

If you want to keep `text` flexibility but enforce format, add CHECKs via a migration:

```sql
ALTER TABLE "Transaction"
  ADD CONSTRAINT txhash_format
  CHECK ("transactionHash" IS NULL OR "transactionHash" ~ '^0x[0-9A-Fa-f]{64}$') NOT VALID;

ALTER TABLE "Transaction"
  ADD CONSTRAINT walletaddr_format
  CHECK ("walletAddress" IS NULL OR "walletAddress" ~ '^0x[0-9A-Fa-f]{40}$') NOT VALID;

-- Validate after cleaning bad rows:
ALTER TABLE "Transaction" VALIDATE CONSTRAINT txhash_format;
ALTER TABLE "Transaction" VALIDATE CONSTRAINT walletaddr_format;
```

(Drizzle can include raw SQL in a migration; use your migration file to add these.)

---

## ⚠️ Process note: avoid schema drift

You’re maintaining **both Prisma and Drizzle** schemas. Only one tool should own DDL/migrations, or they’ll fight each other. Pick one as **source of truth**:

* If Prisma owns migrations, don’t generate/apply Drizzle migrations (and vice versa).
* Keep model parity between them if both clients are used.

---

## Small QoL tweaks

* Add `@@index([createdAt])`-equivalents (you already did on some; add to `transactions` too).
* Consider case-insensitive login: use a lower-cased email in app code or a functional index (`index("users_email_lower").on(sql`lower(${users.email})`)`) if you need it.
* `activities.type` is a good enum candidate (`stake_created`, `mining_completed`, etc.).

---

## Minimal patch (copy/paste)

```ts
// examples to drop into existing definitions

// 1) auto-updating timestamps
updatedAt: timestamp("updatedAt").defaultNow().$onUpdate(() => sql`now()`).notNull(),

// 2) userTasks uniqueness
unique("user_tasks_user_task_unique").on(table.userId, table.taskId),

// 3) transactions uniqueness + indexes
unique("transactions_txhash_unique").on(table.transactionHash),
index("transactions_wallet_idx").on(table.walletAddress),

// 4) higher-precision decimals (one example)
xnrtBalance: decimal("xnrtBalance", { precision: 38, scale: 18 }).default("0").notNull(),
```

---

If you want, I can generate a Drizzle migration file that:

* upgrades all money/token columns to `DECIMAL(38,18)`,
* adds the new unique/index constraints,
* converts `metadata` to `jsonb`,
* and adds the CHECK constraints.
