Comprehensive Client-Side Code Review

The client folder contains a full‑stack React/TypeScript front‑end. It implements authentication, wallet linking, staking, referral tracking and an admin dashboard. This review iterates through the files, summarising the logic, highlighting design strengths, pointing out problems, and suggesting remediations. Due to the number of files, the analysis groups them by directory and focuses on security, correctness, and user‑experience issues. When relevant, recommendations are supported with citations.

Project Overview

Entry points: src/App.tsx chooses between authenticated and unauthenticated layouts using a simple useAuth hook; src/main.tsx wraps the app in context providers (Theme, QueryClient, PWA) and registers the service worker.

Configuration and context: environment‑driven feature flags live in src/config/features.ts; dark/light theme handling is in src/contexts/theme-context.tsx and src/contexts/theme.ts.

Custom hooks: hooks under src/hooks provide authentication state (useAuth.ts), toast notifications (use-toast.ts), confetti animations (use-confetti.ts), mobile detection (use-mobile.tsx) and notification badges (use-notification-badge.ts).

Library wrappers: the src/lib folder exposes helpers for session checking, CSRF token handling, Sentry monitoring and a global QueryClient with custom request/response interceptors.

Components: dozens of UI components live under src/components and src/components/ui wrapping headless UI primitives. High‑level components implement a chatbot, referral leaderboards/tree, PWA prompts, wallet linking, skeleton placeholders and a notification centre.

Pages: under src/pages are user‑facing pages (login, register, deposit, staking, mining, wallet, profile, referrals, rewards, tasks, achievements, leaderboard, etc.) and an extensive admin console with tabs for overview, deposits, withdrawals, users, stakes, tasks, achievements, analytics and settings.

Across the project, code quality is high; there is consistent use of TypeScript, React Query, and Tailwind CSS. Accessibility (ARIA labels) and test IDs are present. However, several security and UX concerns surface upon closer inspection. The following sections document each area.

Top‑Level Files

index.html: sets up the root <div id="root"> and loads the generated script. It references manifest.webmanifest and several icons in public/, but the icon files are mis‑sized (e.g., icon-192.png is 192×120). PWA guidelines require at least 192×192 and 512×512 square icons
vite-pwa-org.netlify.app
; the current icons are full screenshots of the login page rather than simple logos. Recommendation: design square, brand‑consistent icons at 192 px and 512 px (maskable and any), update manifest.webmanifest accordingly and generate all required sizes using a PWA asset generator
developer.mozilla.org
.

vite-env.d.ts: standard TypeScript declarations for Vite; no issues.

Configuration and Context
src/config/features.ts

Loads feature flags from VITE_FEATURE_FLAGS (JSON) and merges them with defaults. The isFeatureEnabled helper normalizes keys and returns a boolean. This approach is flexible; however, the default flags contain production‑only toggles. If a flag is not in VITE_FEATURE_FLAGS, development may enable features unexpectedly. Document default values and set them conservatively.

src/contexts/theme-context.tsx & src/contexts/theme.ts

Provide dark/light theme support using CSS classes and local storage. The context persists the theme and exposes toggleTheme. A side effect toggles the dark class on <html>. This is a robust implementation. Consider storing the theme preference using a cookie to sync across devices and respect OS preference on initial load.

Hooks
useAuth.ts

Fetches /auth/me to determine if a user is authenticated. It returns { user, isAuthenticated }. When the server returns 401 it returns null, but other error codes propagate as exceptions. The hook lacks explicit error handling; an unreachable backend could throw and break the whole app. Wrap the fetch call in a try/catch and return null for unexpected errors with a toast notification.

use-notification-badge.ts

Queries /api/notifications/unread-count every 30 s and uses the Badging API to set the app icon badge. Errors are silently ignored. Consider logging fetch failures and showing a fallback UI.

use-toast.ts

Implements a global toast store with a single toast limit. The TOAST_REMOVE_DELAY is 1_000_000 ms (≈16.7 min), causing toasts to linger for an extremely long time. This appears to be a bug; reduce it to ~5 s so messages auto‑dismiss quickly. Without auto‑dismiss the UI becomes cluttered.

use-confetti.ts

Triggers confetti animations based on celebration type. It respects a feature flag (FEATURE_ANIMATIONS). Implementation is adequate; ensure the imported confetti library only runs on the client side to avoid SSR errors.

use-mobile.tsx

Uses window.matchMedia to detect mobile. This is acceptable for minor UI tweaks, but for feature gating (e.g., wallet linking) rely on user agent detection from the backend for reliability.

useTheme.ts

Provides theme context; integrates with theme-context.tsx and is used by components (e.g., ThemeToggle). No issues.

Library Helpers
lib/auth.ts

requireSession calls /auth/me and throws on failure. If the user is unauthenticated, it redirects to login; otherwise returns. Ensure 401/403 detection is consistent with server responses.

lib/authUtils.ts

Defines isUnauthorizedError and handleUnauthorized which redirect to /api/login after displaying a toast. This uses a generic message (“Please login to continue”). The login and registration pages themselves return distinct error messages for existing email vs username; this difference can lead to user enumeration by comparing responses. OWASP recommends returning the same message for invalid username or password
codesignal.com
.

lib/csrf.ts

ensureCsrf fetches /auth/csrf and stores the token on window.CSRF_TOKEN. The token is reused for subsequent POST/PUT/DELETE requests via queryClient.ts. While better than storing it in local storage, storing CSRF tokens on the global window still exposes them to XSS. OWASP advises using a double‑submit cookie pattern or custom headers delivered via cookies
cheatsheetseries.owasp.org
. Ideally the server should set a XSRF-TOKEN cookie and queryClient.ts should read it from document.cookie rather than window.

lib/monitoring.ts

Initialises Sentry and Web Vitals. Integrations enable browserTracing and replay with maskAllText and blockAllMedia, which protect user privacy. Confirm the DSN and environment are passed via environment variables. The replaysSessionSampleRate is 0.1 (10 % of sessions) while errors sample at 100 %. This is appropriate.

lib/queryClient.ts

Configures a global React Query client. The apiRequest helper attaches CSRF tokens and JSON headers for state‑changing requests. It calls ensureCsrf for each request, which performs a network call; caching the token per session may reduce overhead. Also, apiRequest treats any non‑OK response as an error, returning the JSON error body if possible. Consider exposing error types to the caller so the UI can react accordingly.

Components

The src/components directory contains both simple UI wrappers (in ui/) and higher‑level components. The UI wrappers are mostly thin layers over Radix UI or custom styled primitives; they are robust and not further analysed. Below we focus on the complex components.

Sidebar (app-sidebar.tsx)

Renders the navigation sidebar. It fetches the current user to determine if the admin panel should be shown. The logo uses public/icon-192.png, a non‑square screenshot of the login page. PWA icons should be square and show only the app logo
vite-pwa-org.netlify.app
. Replace the logo with the new square icon recommended above. Additionally, the logout button posts to /auth/logout and unconditionally redirects to /, ignoring failures. Check the response status; if logout fails, surface an error toast instead of redirecting prematurely.

Chatbot (chat-bot.tsx)

Implements a FAQ‑driven chatbot. It tokenises user messages, scores them against known Q&A pairs and returns the best match. Problems found:

Hard‑coded knowledge: The FAQ contains outdated information about deposit conversion (1 USDT = 1 XNRT). The deposit page uses USDT_TO_XNRT_RATE = 100, causing inconsistency. Sync constants across the application by fetching conversion rates from the backend or a shared configuration file.

No natural‑language processing: The naive keyword matching might not match user queries. For a better experience, consider using a small language model on the server or an FAQ search that ranks by semantic similarity.

Data privacy: The chatbot logs user messages to session storage. Ensure sensitive data (passwords or private keys) aren’t inadvertently stored.

Check‑in Calendar (checkin-calendar.tsx)

Displays daily check‑in streaks using date‑fns. It uses React Query to fetch /api/checkin-history. The calendar uses static arrays of days and months; watch for locale support. Consider generating the calendar using date-fns functions to handle month lengths and avoid off‑by‑one errors.

Wallet Linking (link-wallet-card.tsx & manual-link-wallet-dialog.tsx)

link-wallet-card.tsx uses MetaMask/Trust Wallet if available and falls back to manual linking. It ensures a session exists and obtains a CSRF token before initiating the link challenge. Issues:

Inconsistent mobile detection: It uses a regex to detect mobile user agents; this may fail on certain browsers. Server‑side detection (e.g., reading User-Agent header) is more reliable.

CSRF token storage: The manual dialog sends the token from window.CSRF_TOKEN. As noted, storing tokens on window exposes them to XSS; adopt double‑submit cookie pattern
cheatsheetseries.owasp.org
.

Error messages: The functions catch generic errors and show them in toasts, but they log the error to console.error as well. While helpful for debugging, avoid logging user data in production.

Notification Centre (notification-center.tsx)

Provides in‑app and push notification support. It shows unread counts, allows marking notifications as read, and manages subscription to push notifications using the VAPID key from the backend. Observations:

Push subscription state: It calls navigator.serviceWorker.ready to check the subscription. If the service worker fails to register (e.g., due to offline mode), ready may never resolve. Add a timeout and catch errors to avoid a permanently loading state.

Feature flag: The ENABLE_PUSH_NOTIFICATIONS constant is set to true unconditionally. If push notifications are not supported in certain environments, this should be controlled by a feature flag.

Security: When sending subscription details, ensure the server validates the auth and p256dh keys; if compromised, a malicious script could subscribe the user to a rogue push service.

PWA Installation & Update Prompts

pwa-install-prompt.tsx listens to beforeinstallprompt to show a custom install prompt and respects a 7‑day dismissal cookie. pwa-update-notification.tsx listens for a custom sw-update-available event to prompt users to refresh the app. Both components are well‑designed. They rely on proper service worker events fired from sw.ts (see below).

Referral Leaderboard and Tree

These components fetch referral data and display leaderboards and referral networks. They handle loading states and admin view (shows user IDs) elegantly. Ensure the backend paginates results to avoid large payloads. The referral tree truncates each level to 8 items, adding a “+X more” indicator; consider a modal to view all referrals.

Report Missing Deposit (report-missing-deposit.tsx)

Users can report missing deposits by providing a transaction hash, amount and description. The component calls /api/wallet/report-deposit and displays different toasts based on the response. Observations:

Validation: It only checks that the amount is positive and the hash is present. Use regex to validate that the transaction hash matches the expected 64‑hex character pattern (/^0x[0-9a-fA-F]{64}$/).

API feedback: The server returns different flags (credited, verified, pendingAdminReview), but the client uses fallback messaging for failures. Keep the messages consistent with server responses.

Rotating Glass, Skeletons, ThemeToggle

These are purely visual components. They are implemented cleanly with accessible props.

XP Leaderboard

Similar to the referral leaderboard but ranking users by XP. It allows switching between categories (overall, mining, staking, referrals) and time periods. The server must ensure proper ranking logic. Hide the admin‑only fields (user ID, email) behind a permission check.

Pages
src/pages/auth (login, register, forgot/reset password, verify email)

Login & Register forms: They send JSON to /auth/login and /auth/register. After success they reload the page to update useAuth state. Issues:

CSRF tokens missing: The login and registration forms send credentials without a CSRF token. Although cookies are SameSite=Strict, sending a CSRF header is recommended
cheatsheetseries.owasp.org
. Use ensureCsrf before submitting forms.

User enumeration: The registration error messages differ for existing email vs username. Attackers could enumerate accounts by registering common usernames and reading the error. Respond with a generic message (e.g., “Username or email already in use”)
codesignal.com
.

Weak password policy: The registration form uses a simple password field without strength indicator or complexity requirements. Consider integrating the password-strength component from ui and enforce minimum length and character diversity.

Forgot & Reset Password: These pages call /auth/forgot-password and /auth/reset-password. The reset password form should confirm the new password and require a strong password.

src/pages/deposit.tsx

Allows users to deposit USDT and claim XNRT. The page fetches deposit history and deposit addresses, displays QR codes and deposit instructions, and lets the user upload proof of payment. Key issues:

Hard‑coded company wallet and exchange rate: The constant USDT_TO_XNRT_RATE = 100 defines the conversion rate; the wallet address is a literal 0x715C32deC9534d2fB34e0B567288AF8d895efB59. These values should come from the backend via API or environment variables to avoid stale data and potential security risks.

Base64 file upload: The deposit proof image is read with FileReader and encoded in Base64 before being sent to the server. Base64 increases payload size by ~33%
celerdata.com
 and may trigger request size limits. Upload the file using FormData and multipart requests instead.

File type checking: The page checks the MIME type but not the actual file content (MIME types can be forged). Validate file types on the server side; limit accepted formats (PNG/JPG) and file sizes.

CSRF token usage: The deposit submission uses apiRequest which adds the CSRF token header. This is good, but ensure that ensureCsrf sets a secure cookie rather than storing the token on window (see above).

src/pages/staking.tsx

Implements staking with tier selection, maturity countdowns and reward processing. Observations:

Automatic reward processing: On mount, the page calls /api/stakes/process-rewards. Triggering a state‑changing API call just by visiting the page is surprising. Expose reward processing behind a button or schedule it via a background job on the server.

Tier selection: When users click “Stake,” the code uses selectedTier but does not check if it is undefined. Add validation to prevent undefined or invalid tiers from being sent to the backend.

Countdown timer: The timer uses setInterval without clearing it in all branches (e.g., if the stake matures mid‑session). Clear intervals on unmount to prevent memory leaks.

Withdrawal logic: It calls /api/stakes/withdraw without confirming that the stake is mature; rely on server validation. Display clearer messaging to users about early withdrawal penalties or restrictions.

src/pages/mining.tsx

Displays mining status and allows starting/stopping mining sessions. It calls /api/mining/process-rewards and uses websockets or polling to update current session details. Ensure the client handles network failures and respects server‑side rate limits.

src/pages/wallet.tsx

Shows wallet balances and linked wallets. It uses link-wallet-card.tsx to link wallets and report-missing-deposit.tsx to report missing deposits. If the user has no linked wallets, consider hiding features that require one. The balance values should use Intl.NumberFormat to respect locale.

src/pages/withdrawal.tsx

Allows users to request withdrawals to their BSC wallets. It should require the user to have a verified email and a linked wallet. Validate the withdrawal amount against available balance and minimum/maximum limits.

src/pages/profile.tsx

Displays and updates user profile details (display name, email, referral code). Ensure forms are protected by CSRF tokens. Validate user input to prevent XSS (e.g., sanitise display name before rendering).

Admin Pages (summary)

The admin dashboard is extensive. The overview tab displays high‑level statistics. Deposits and withdrawals tabs provide review/approval flows with bulk actions, search and proof image previews. Users, stakes, tasks, achievements, analytics and settings tabs provide management interfaces. Observations:

Bulk approval/rejection: Both deposits and withdrawals tabs implement bulk actions. They maintain a Set of selected IDs and show a sticky bar at the bottom. Always validate the state on the backend; the client may select outdated entries if the list is refreshed.

Hard‑coded wallet address: The deposit tab displays XNRT Wallet: 0x715C32deC9534d2fB34e0B567288AF8d895efB59 (BEP20) in the card description. This should come from server configuration.

Verification logic: The admin can click “Verify” to call /api/admin/deposits/{id}/verify, which checks transaction confirmations on BSC. Display the number of confirmations and block auto‑approval if below a threshold (e.g., <10 confirmations). Show warnings for non‑standard token transfers.

Filtering and searching: The pages allow searching by transaction hash, user email and username. Consider server‑side search to handle large datasets.

Rate limits and session expiry: Many admin actions call POST endpoints that mutate state. Use CSRF tokens and handle 401/403 responses by redirecting to login (similar to normal pages).

Service Worker (src/sw.ts)

Defines a custom Workbox service worker with a versioned cache and runtime caching strategies. It precaches Google fonts, CSS/JS bundles, manifest and icons. It uses NetworkOnly for /auth/* and /api/wallet/* to avoid caching sensitive requests and NetworkFirst for other /api/* requests with a 1‑minute cache. The service worker also listens for a catch handler to provide offline fallback messages.

Observations:

Cache versioning: The CACHE_VERSION is a static string. Bump this value whenever assets change to bust outdated caches.

Offline fallback: For navigations, NetworkOnly is used for /auth and /api/wallet but NetworkFirst for /api/*. Consider using StaleWhileRevalidate for frequently accessed API endpoints to provide instant responses when offline.

Security: The service worker excludes caching for authentication routes; good. Confirm that the service worker cannot intercept token or private data (e.g., it does not cache responses containing JWT or CSRF tokens).

Public Assets

The public folder contains icons and favicons. Many icons are non‑square and full‑page screenshots. According to PWA guidelines, the manifest must include at least 192 px and 512 px square icons
vite-pwa-org.netlify.app
. The maskable icon should be provided to enable proper cropping on Android. Replace all icons with properly sized, brand‑only images; update manifest.webmanifest. Avoid placing UI screenshots in icons because they become tiny and illegible on home screens
developer.mozilla.org
.

Security & Best Practices Summary

The client application is well‑structured but can improve security and UX by adopting the following practices:

Use environment variables for secrets and constants. Hard‑coded conversion rates, wallet addresses and JWT secrets (server side) should be supplied via environment variables. Storing secrets in code risks accidental exposure
medium.com
.

Prevent user enumeration. Unify error messages during registration and login so attackers cannot infer whether a username or email is registered
codesignal.com
.

Strengthen CSRF protection. Use a signed double‑submit cookie or set CSRF tokens via secure cookies rather than storing them on window
cheatsheetseries.owasp.org
.

Avoid Base64 for file uploads. Send proof images using multipart/form‑data to reduce payload bloat and server processing overhead
celerdata.com
.

Validate inputs rigorously. Use regex to validate Ethereum addresses, transaction hashes and numeric fields. Validate file types and sizes on both client and server.

Shorten toast duration. Reduce TOAST_REMOVE_DELAY to a few seconds to prevent stale notifications.

Provide proper PWA icons. Generate square icons (192×192 and 512×512) and maskable variants; update the manifest accordingly
vite-pwa-org.netlify.app
.

Avoid auto‑executing mutations on page load. Don’t call reward processing or other state‑changing endpoints automatically when a page loads; let the user trigger the action or run it on the server in the background.

Ensure network errors are handled gracefully. Wrap fetch calls in try/catch blocks, display appropriate error messages, and avoid leaving loading spinners indefinitely.

Follow JWT best practices. Ensure the secret used to sign tokens is never hard‑coded and tokens include appropriate expiration times; store secrets in environment variables
medium.com
.

By addressing these issues, the application will be more secure, reliable and user‑friendly.