--- shared/schema.ts+++ shared/schema.ts@@ -136,7 +136,8 @@   index("transactions_userId_idx").on(table.userId),
   index("transactions_type_idx").on(table.type),
   index("transactions_status_idx").on(table.status),
-]);
+
+  , unique("transactions_txhash_type_unique").on(table.transactionHash, table.type)]);
 
 // Tasks
 export const tasks = pgTable("Task", {
@@ -458,3 +459,61 @@ } as const;
 
 export type StakingTier = keyof typeof STAKING_TIERS;
+
+// Linked wallets (address -> user)
+export const linkedWallets = pgTable("LinkedWallet", {
+  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
+  userId: varchar("userId").notNull().references(() => users.id, { onDelete: "cascade" }),
+  address: varchar("address").unique().notNull(), // store lowercase
+  verified: boolean("verified").default(true).notNull(),
+  createdAt: timestamp("createdAt").defaultNow().notNull(),
+}, (table) => [
+  index("linkedWallets_userId_idx").on(table.userId),
+]);
+
+// Chain scan cursor
+export const chainCursors = pgTable("ChainCursor", {
+  id: varchar("id").primaryKey(), // e.g. 'bsc:usdt:toTreasury'
+  block: integer("block").notNull(),
+  updatedAt: timestamp("updatedAt").defaultNow().notNull(),
+});
+
+// Unmatched deposits (sender not linked or linked post-facto)
+export const unmatchedDeposits = pgTable("UnmatchedDeposit", {
+  txHash: varchar("txHash").primaryKey(),
+  from: varchar("from").notNull(),
+  to: varchar("to").notNull(),
+  usdtAmount: decimal("usdtAmount", { precision: 18, scale: 6 }).notNull(),
+  blockNumber: integer("blockNumber").notNull(),
+  note: text("note"),
+  createdAt: timestamp("createdAt").defaultNow().notNull(),
+}, (table) => [
+  index("unmatched_from_idx").on(table.from),
+  index("unmatched_created_idx").on(table.createdAt),
+]);
+
+// Off-chain token mint/burn ledger
+export const tokenLedger = pgTable("TokenLedger", {
+  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
+  userId: varchar("userId").notNull().references(() => users.id, { onDelete: "cascade" }),
+  kind: varchar("kind").notNull(), // 'mint_deposit' | 'burn_adjust' | 'airdrop' | 'batch_grant'
+  amount: decimal("amount", { precision: 18, scale: 6 }).notNull(), // +/-
+  meta: jsonb("meta"),
+  createdAt: timestamp("createdAt").defaultNow().notNull(),
+}, (table) => [
+  index("tokenLedger_userId_idx").on(table.userId),
+  index("tokenLedger_created_idx").on(table.createdAt),
+]);
+
+// Signature nonces for wallet linking
+export const signNonces = pgTable("SignNonce", {
+  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
+  userId: varchar("userId").notNull().references(() => users.id, { onDelete: "cascade" }),
+  nonce: varchar("nonce").unique().notNull(),
+  expiresAt: timestamp("expiresAt").notNull(),
+  usedAt: timestamp("usedAt"),
+  createdAt: timestamp("createdAt").defaultNow().notNull(),
+}, (table) => [
+  index("signNonces_userId_idx").on(table.userId),
+  index("signNonces_expires_idx").on(table.expiresAt),
+]);

--- server/services/bscWatcher.ts+++ server/services/bscWatcher.ts@@ -0,0 +1,183 @@+import { ethers } from 'ethers';
+import { db } from '../db';
+import * as s from '@shared/schema';
+import { and, eq, sql } from 'drizzle-orm';
+
+const RPC       = process.env.RPC_BSC_URL!;
+const USDT      = (process.env.USDT_BSC_ADDRESS || '').toLowerCase();
+const TREASURY  = (process.env.XNRT_WALLET || '').toLowerCase();
+const REQ_CONF  = Number(process.env.BSC_CONFIRMATIONS ?? 12);
+const RATE_STR  = process.env.XNRT_RATE_USDT ?? '100'; // integer rate
+
+const provider  = new ethers.JsonRpcProvider(RPC);
+const IFACE     = new ethers.Interface(["event Transfer(address indexed from,address indexed to,uint256 value)"]);
+const CURSOR_ID = 'bsc:usdt:toTreasury';
+
+let running = false;
+// @ts-ignore
+if (!(globalThis as any).__bscWatcherStarted) (globalThis as any).__bscWatcherStarted = false;
+
+function mulDecimalStr(a: string, b: string, scaleA = 18, scaleB = 0, outScale = 2) {
+  const toInt = (s: string, scale: number) => {
+    const [i, f = ""] = s.split(".");
+    const ff = (f + "0".repeat(scale)).slice(0, scale);
+    return BigInt(i + ff);
+  };
+  const A = toInt(a, scaleA);
+  const B = toInt(b, scaleB);
+  const prod = A * B; // scale = scaleA + scaleB
+  const outDivPow = scaleA + scaleB - outScale;
+  const outDiv = 10n ** BigInt(outDivPow);
+  const q = prod / outDiv;
+  const r = prod % outDiv;
+  const frac = r.toString().padStart(outScale, "0");
+  const int = q.toString();
+  return outScale > 0 ? `${int}.${frac}` : int;
+}
+
+export async function startBscUsdtWatcher() {
+  if (process.env.AUTO_DEPOSIT !== 'true') {
+    console.log('[Watcher] AUTO_DEPOSIT disabled');
+    return;
+  }
+  if (!RPC || !USDT || !TREASURY) {
+    console.warn('[Watcher] Missing env RPC_BSC_URL/USDT_BSC_ADDRESS/XNRT_WALLET');
+    return;
+  }
+  // @ts-ignore
+  if ((globalThis as any).__bscWatcherStarted) return;
+  // @ts-ignore
+  (globalThis as any).__bscWatcherStarted = true;
+
+  const cur = await db.query.chainCursors.findFirst({ where: eq(s.chainCursors.id, CURSOR_ID) });
+  let cursorBlock = cur?.block ?? (await provider.getBlockNumber()) - 3;
+  if (!cur) {
+    await db.insert(s.chainCursors).values({ id: CURSOR_ID, block: cursorBlock }).onConflictDoNothing();
+  }
+  console.log('[Watcher] Starting from block', cursorBlock);
+
+  const loop = async () => {
+    if (running) return;
+    running = true;
+    try {
+      const latest = await provider.getBlockNumber();
+      const fromBlock = cursorBlock + 1;
+      const toBlock   = Math.min(latest - REQ_CONF, fromBlock + 999);
+      if (toBlock < fromBlock) return;
+
+      const logs = await provider.getLogs({
+        fromBlock, toBlock, address: USDT,
+        topics: [ethers.id("Transfer(address,address,uint256)"), null, ethers.zeroPadValue(TREASURY, 32)],
+      });
+
+      for (const log of logs) {
+        const parsed = IFACE.parseLog({ topics: log.topics, data: log.data });
+        const from  = (parsed.args[0] as string).toLowerCase();
+        const to    = (parsed.args[1] as string).toLowerCase();
+        const value = parsed.args[2] as bigint;
+        const txHash = log.transactionHash.toLowerCase();
+
+        // skip if processed
+        const exist = await db.query.transactions.findFirst({
+          where: and(eq(s.transactions.transactionHash, txHash), eq(s.transactions.type, 'deposit')),
+          columns: { id: true }
+        });
+        if (exist) continue;
+
+        const link = await db.query.linkedWallets.findFirst({ where: eq(s.linkedWallets.address, from) });
+
+        const receipt = await provider.getTransactionReceipt(txHash).catch(() => null);
+        if (!receipt || receipt.status !== 1 || receipt.blockNumber == null) {
+          if (!link) {
+            await db.insert(s.unmatchedDeposits).values({
+              txHash, from, to, usdtAmount: ethers.formatUnits(value, 18), blockNumber: log.blockNumber
+            }).onConflictDoNothing();
+          }
+          continue;
+        }
+        const conf = (await provider.getBlockNumber()) - (receipt.blockNumber ?? latest);
+        if (conf < REQ_CONF) continue;
+
+        const block = await provider.getBlock(receipt.blockNumber);
+        const txTimeMs = Number(block.timestamp) * 1000;
+
+        if (!link) {
+          await db.insert(s.unmatchedDeposits).values({
+            txHash, from, to, usdtAmount: ethers.formatUnits(value, 18), blockNumber: receipt.blockNumber
+          }).onConflictDoNothing();
+          continue;
+        }
+        if (link.createdAt && link.createdAt.getTime() > txTimeMs) {
+          await db.insert(s.unmatchedDeposits).values({
+            txHash, from, to,
+            usdtAmount: ethers.formatUnits(value, 18),
+            blockNumber: receipt.blockNumber,
+            note: 'Linked after transfer; requires manual review'
+          }).onConflictDoUpdate({
+            target: s.unmatchedDeposits.txHash,
+            set: { note: 'Linked after transfer; requires manual review' }
+          });
+          continue;
+        }
+
+        const usdtStr = ethers.formatUnits(value, 18);
+        const xnrtStr = mulDecimalStr(usdtStr, RATE_STR, 18, 0, 2);
+
+        await db.transaction(async (trx) => {
+          // ensure balance
+          const bal = await trx.query.balances.findFirst({ where: eq(s.balances.userId, link.userId) });
+          if (!bal) await trx.insert(s.balances).values({ userId: link.userId });
+
+          // create tx
+          await trx.insert(s.transactions).values({
+            userId: link.userId,
+            type: 'deposit',
+            amount: xnrtStr,
+            usdtAmount: usdtStr,
+            walletAddress: TREASURY,
+            transactionHash: txHash,
+            status: 'approved',
+            verified: true,
+            confirmations: conf,
+            verificationData: { auto: true, from, to, usdt: usdtStr } as any,
+          } as any);
+
+          // credit balance
+          await trx.execute(sql`
+            UPDATE "Balance"
+            SET "xnrtBalance" = ("xnrtBalance"::numeric + ${xnrtStr}::numeric),
+                "totalEarned" = ("totalEarned"::numeric + ${xnrtStr}::numeric),
+                "updatedAt" = now()
+            WHERE "userId" = ${link.userId}
+          `);
+
+          // ledger
+          await trx.insert(s.tokenLedger).values({
+            userId: link.userId,
+            kind: 'mint_deposit',
+            amount: xnrtStr,
+            meta: { txHash, usdt: usdtStr } as any
+          } as any);
+        });
+
+        // cleanup unmatched if existed
+        await db.delete(s.unmatchedDeposits).where(eq(s.unmatchedDeposits.txHash, txHash));
+
+        console.log(`[Watcher] Credited ${xnrtStr} XNRT for user ${link.userId} (tx ${txHash})`);
+      }
+
+      cursorBlock = toBlock;
+      await db.insert(s.chainCursors).values({ id: CURSOR_ID, block: cursorBlock }).onConflictDoUpdate({
+        target: s.chainCursors.id,
+        set: { block: cursorBlock, updatedAt: sql`now()` }
+      });
+    } catch (e) {
+      console.error('[Watcher] Error:', e);
+    } finally {
+      running = false;
+    }
+  };
+
+  void loop();
+  setInterval(loop, 6000);
+}

--- server/index.ts+++ server/index.ts@@ -5,6 +5,7 @@ import { registerRoutes } from "./routes";
 import { setupVite, serveStatic, log } from "./vite";
 import { startRetryWorker, stopRetryWorker } from "./retryWorker";
+import { startBscUsdtWatcher } from "./services/bscWatcher";
 
 const app = express();
 
@@ -108,6 +109,7 @@     log(`serving on port ${port}`);
     
     startRetryWorker();
+    startBscUsdtWatcher();
   });
 
   process.on('SIGTERM', () => {

--- server/routes.ts+++ server/routes.ts@@ -7,8 +7,13 @@ import { PrismaClient, Prisma } from "@prisma/client";
 import { notifyUser, sendPushNotification } from "./notifications";
 import webpush from "web-push";
+import crypto from "crypto";
+import { isAddress, getAddress, verifyMessage } from "ethers";
 import rateLimit from "express-rate-limit";
 import { verifyBscUsdtDeposit } from "./services/verifyBscUsdt";
+import { db } from "./db";
+import * as s from "@shared/schema";
+import { and, eq, desc } from "drizzle-orm";
 
 const prisma = new PrismaClient();
 
@@ -2332,3 +2337,159 @@   const httpServer = createServer(app);
   return httpServer;
 }
+
+// --- Admin: Unmatched deposit review (drizzle) ---
+app.get('/api/admin/unmatched-deposits', requireAuth, requireAdmin, async (req, res) => {
+  try {
+    const rows = await db.select().from(s.unmatchedDeposits).orderBy(desc(s.unmatchedDeposits.createdAt)).limit(200);
+    res.json(rows);
+  } catch (e) {
+    console.error('List unmatched error:', e);
+    res.status(500).json({ message: 'Failed to list unmatched' });
+  }
+});
+
+app.post('/api/admin/unmatched-deposits/:txHash/match', requireAuth, requireAdmin, validateCSRF, async (req, res) => {
+  try {
+    const txHash = String(req.params.txHash).toLowerCase();
+    const row = await db.query.unmatchedDeposits.findFirst({ where: eq(s.unmatchedDeposits.txHash, txHash) });
+    if (!row) return res.status(404).json({ message: 'Not found' });
+
+    const link = await db.query.linkedWallets.findFirst({ where: eq(s.linkedWallets.address, row.from.toLowerCase()) });
+    if (!link) return res.status(400).json({ message: 'Sender address not linked to any user' });
+
+    const exist = await db.query.transactions.findFirst({ where: and(eq(s.transactions.transactionHash, txHash), eq(s.transactions.type, 'deposit')) });
+    if (exist) {
+      await db.delete(s.unmatchedDeposits).where(eq(s.unmatchedDeposits.txHash, txHash));
+      return res.json({ ok: true, message: 'Already credited; cleaned' });
+    }
+
+    const usdtStr = String(row.usdtAmount);
+    const rate = process.env.XNRT_RATE_USDT ?? '100';
+    const amountNum = (Number(usdtStr) * Number(rate)).toFixed(2);
+
+    await db.transaction(async (trx) => {
+      const bal = await trx.query.balances.findFirst({ where: eq(s.balances.userId, link.userId) });
+      if (!bal) await trx.insert(s.balances).values({ userId: link.userId });
+
+      await trx.insert(s.transactions).values({
+        userId: link.userId,
+        type: 'deposit',
+        amount: amountNum,
+        usdtAmount: usdtStr,
+        walletAddress: process.env.XNRT_WALLET || null,
+        transactionHash: txHash,
+        status: 'approved',
+        verified: true,
+        confirmations: 999,
+        verificationData: { auto: false, manualMatch: true, from: row.from } as any,
+      } as any);
+
+      await trx.execute(sql`
+        UPDATE "Balance"
+        SET "xnrtBalance" = ("xnrtBalance"::numeric + ${amountNum}::numeric),
+            "totalEarned" = ("totalEarned"::numeric + ${amountNum}::numeric),
+            "updatedAt" = now()
+        WHERE "userId" = ${link.userId}
+      `);
+
+      await trx.insert(s.tokenLedger).values({
+        userId: link.userId,
+        kind: 'mint_deposit',
+        amount: amountNum,
+        meta: { txHash, from: row.from, manual: true } as any
+      } as any);
+
+      await trx.delete(s.unmatchedDeposits).where(eq(s.unmatchedDeposits.txHash, txHash));
+    });
+
+    res.json({ ok: true });
+  } catch (e) {
+    console.error('Match unmatched error:', e);
+    res.status(500).json({ message: 'Failed to match deposit' });
+  }
+});
+// --- end admin block ---
+
+// --- Wallet Linking via MetaMask (EIP-191) ---
+app.get('/api/wallet/link/challenge', requireAuth, async (req, res) => {
+  try {
+    const userId = req.authUser!.id;
+    const addressRaw = String((req.query as any)?.address || '');
+    if (!addressRaw || !isAddress(addressRaw)) return res.status(400).json({ message: 'Valid address required' });
+    const addrLc = addressRaw.toLowerCase();
+
+    const ttlMin = Number(process.env.NONCE_TTL_MIN ?? 10);
+    const expiresAt = new Date(Date.now() + ttlMin * 60 * 1000);
+    const nonce = crypto.randomUUID();
+
+    await db.insert(s.signNonces).values({ userId, nonce, expiresAt }).onConflictDoNothing();
+
+    const domain = process.env.APP_DOMAIN || req.hostname;
+    const message = [
+      `Link Wallet to XNRT Account`,
+      ``,
+      `Domain: ${domain}`,
+      `Address: ${getAddress(addrLc)}`,
+      `Nonce: ${nonce}`,
+      `Expires: ${expiresAt.toISOString()}`
+    ].join('\n');
+
+    res.json({ message, nonce, address: getAddress(addrLc), expiresAt: expiresAt.toISOString() });
+  } catch (e) {
+    console.error('Challenge error:', e);
+    res.status(500).json({ message: 'Failed to create challenge' });
+  }
+});
+
+app.post('/api/wallet/link/confirm', requireAuth, validateCSRF, async (req, res) => {
+  try {
+    const userId = req.authUser!.id;
+    const { address, signature, nonce } = req.body as { address?: string, signature?: string, nonce?: string };
+    if (!address || !isAddress(address)) return res.status(400).json({ message: 'Valid address required' });
+    if (!signature || !nonce) return res.status(400).json({ message: 'Signature and nonce required' });
+
+    const addrLc = address.toLowerCase();
+    const sn = await db.query.signNonces.findFirst({ where: eq(s.signNonces.nonce, nonce) });
+    if (!sn || sn.userId !== userId) return res.status(400).json({ message: 'Invalid nonce' });
+    if (sn.usedAt) return res.status(400).json({ message: 'Nonce already used' });
+    if (sn.expiresAt.getTime() < Date.now()) return res.status(400).json({ message: 'Nonce expired' });
+
+    const domain = process.env.APP_DOMAIN || req.hostname;
+    const message = [
+      `Link Wallet to XNRT Account`,
+      ``,
+      `Domain: ${domain}`,
+      `Address: ${getAddress(addrLc)}`,
+      `Nonce: ${nonce}`,
+      `Expires: ${sn.expiresAt.toISOString()}`
+    ].join('\n');
+
+    let recovered: string;
+    try {
+      recovered = verifyMessage(message, signature).toLowerCase();
+    } catch {
+      return res.status(400).json({ message: 'Invalid signature' });
+    }
+    if (recovered !== addrLc) return res.status(400).json({ message: 'Signature does not match address' });
+
+    const existing = await db.query.linkedWallets.findFirst({ where: eq(s.linkedWallets.address, addrLc) });
+    if (existing && existing.userId !== userId) {
+      return res.status(409).json({ message: 'This address is already linked to another account' });
+    }
+
+    if (!existing) {
+      await db.insert(s.linkedWallets).values({ userId, address: addrLc, verified: true }).onConflictDoNothing();
+    } else {
+      await db.update(s.linkedWallets).set({ userId, verified: true }).where(eq(s.linkedWallets.address, addrLc));
+    }
+
+    await db.update(s.signNonces).set({ usedAt: new Date() }).where(eq(s.signNonces.nonce, nonce));
+
+    res.json({ address: getAddress(addrLc), verified: true });
+  } catch (e) {
+    console.error('Confirm link error:', e);
+    res.status(500).json({ message: 'Failed to link wallet' });
+  }
+});
+// --- end wallet linking ---
