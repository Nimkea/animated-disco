The routes.ts file is the core API layer for your XNRT platform. It registers dozens of endpoints covering user balances, staking/mining, referrals, tasks, achievements, wallet linking, deposits/withdrawals, notifications, admin dashboards and analytics. Below are the key observations and recommendations.

Structure and readability

File size & cohesion: The file is ~2,800 lines long and tries to handle all of the application’s business logic directly within route callbacks. This makes it difficult to read, test or maintain. Consider refactoring into smaller controllers/services (e.g. stakingController, miningController, adminController) and moving validation and business logic into separate service modules. This will also help isolate unit tests.

Repeated try/catch patterns: Almost every route repeats the same try { … } catch { … } structure with console.error() and a 500 response. You can reduce duplication by using an async error‑handling middleware or helper wrapper (e.g. withErrorHandler(fn)).

Security & validation

CSRF protection: You correctly guard most state‑changing routes with validateCSRF, which attaches a CSRF token to headers. OWASP recommends including anti‑CSRF tokens in a custom header so that browsers enforce same‑origin policies
cheatsheetseries.owasp.org
. Ensure that all POST/PUT/PATCH/DELETE endpoints use this middleware. A few endpoints (/admin/unmatched-deposits/:id/match, some admin bulk operations) already do this; continue to review for gaps.

Rate limiting: You apply a rate limiter to push subscription routes; extend similar throttling to other sensitive operations (login, password resets, deposit/withdrawal reporting) to prevent abuse.

Input validation: Many endpoints manually check request parameters (e.g. regex for Ethereum addresses, numeric parsing). For robustness and safety, consider a declarative validation library like zod or Joi to define schemas. This avoids repeated checks and ensures consistent 400 responses for malformed requests.

Error messages: Some admin responses include specific reasons when an operation fails (e.g. “Deposit ${id} not verified”). While helpful for the admin, avoid exposing internal IDs or error details in public‑facing endpoints. When handling authentication failures, use generic messages to prevent user enumeration
codesignal.com
.

Business logic comments

Staking: The create/withdraw logic correctly checks tier bounds, balances and maturity. Profit calculation uses the original daily rate stored with the stake (good). Ensure that your daily rate table aligns with published APYs and handle early‑withdrawal penalties if needed.

Mining: Sessions are prevented from overlapping. The stop endpoint awards XP and XNRT based on finalReward and uses non‑blocking notifications. Confirm that processMiningRewards (not shown) marks expired sessions and calculates ad boosts.

Referrals: Stats calculation sums referral commissions across three levels and returns anonymized handles for non‑admins. Commission reconciliation via /admin/reconcile-referrals deletes all referral records and recalculates from approved deposits—perform this during low‑traffic windows since it’s a heavy operation.

Deposits: /api/wallet/report-deposit auto‑credits deposits if the on‑chain sender matches a linked wallet; otherwise it creates an unmatched deposit for admin review. This flow protects against spoofed transactions. The route also checks for duplicate transaction hashes and deposit reports.

Withdrawals: A 2% fee is hard‑coded; ensure this matches your published terms. Minimum withdrawals for mining/referral are enforced. Consider logging withdrawals for AML/forensic trail.

Admin modules: There are extensive admin routes for approving/rejecting deposits and withdrawals, bulk operations, CRUD for stakes/tasks/achievements, analytics and activities. These rely heavily on direct Prisma calls. Validate admin input and guard against ID enumeration (e.g. verifying ownership before updating records).

TypeScript issues

The TypeScript errors listed at the end are mostly lint warnings:

Unused imports/parameters (Request and many req parameters aren’t referenced). Prefix unused parameters with _req or remove unused imports.

Invalid orderBy fields: detectedAt and reportedAt are not present on the Prisma models indicated. Check your Prisma schema for the correct column names (likely createdAt).

Nullable fields: report.amount is nullable; check for null before converting to a number. Similarly, use report.txHash instead of transactionHash if your Prisma model names that field differently.

Fields like resolvedBy don’t exist on your depositReport model; use resolvedAt or update your Prisma schema accordingly.

Fixing these will eliminate TypeScript warnings and improve type safety.

Environment & configuration

VAPID keys: You strip extra JSON from process.env.VAPID_PUBLIC_KEY and .VAPID_PRIVATE_KEY—ensure these env vars are stored securely and not committed. Use a config loader to validate that they exist at startup (similar to your validateEnv.ts).

Rates & fees: Hard‑coded values like XNRT_RATE_USDT, withdrawal fee (2%), mining rewards and daily staking rates should come from environment variables or configuration tables to allow adjustments without code changes.

Recommendations

Refactor the route file into separate modules and controllers for maintainability.

Centralize validation and error handling with middleware/helpers to reduce duplication.

Use schema validation (e.g. zod) for request bodies and query parameters.

Consistently protect all state‑changing endpoints with CSRF and rate‑limiting middleware.

Resolve TypeScript errors by removing unused parameters/imports, checking nullable values, and aligning field names with Prisma schema.

Avoid exposing sensitive details in error responses; adopt generic error messages for user‑facing endpoints
codesignal.com
.

Externalize business constants (token conversion rates, fees) into a config file or environment variables for easier tuning.

By addressing these points, your API layer will be more secure, maintainable and aligned with best practices.