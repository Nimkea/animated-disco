Got it—here’s a focused review of everything you shared

* `client/src/lib/authUtils.ts`

  ```ts
  // Referenced from Replit Auth blueprint
  export function isUnauthorizedError(error: Error): boolean {
    return /^401: .*Unauthorized/.test(error.message);
  }
  ```
* `client/src/lib/utils.ts`

  ```ts
  import { clsx, type ClassValue } from "clsx"
  import { twMerge } from "tailwind-merge"

  export function cn(...inputs: ClassValue[]) {
    return twMerge(clsx(inputs))
  }
  ```

# Quick verdicts

* `utils.ts (cn)` — perfect.
* `authUtils.ts` — regex-based check is fragile; prefer checking a `status` or `code` field you control (see fix below).
* `pages/mining.tsx` — solid & readable; a few correctness, UX, and resilience tweaks will make it sturdier.
* `hooks/use-confetti.ts` — nice API! Two footguns: optional chaining around feature flags and unsupported confetti shapes.

---

## Targeted fixes & improvements

### 1) Make unauthorized detection reliable

The regex assumes a particular error message string. If `apiRequest` throws an error with a `status` or `code`, key off that instead and fall back to a lenient message check.

```ts
// client/src/lib/authUtils.ts
export type ApiError = Error & {
  status?: number;
  code?: string;
};

export function isUnauthorizedError(error: unknown): boolean {
  const e = error as ApiError;
  if (typeof e?.status === "number") return e.status === 401;
  if (typeof e?.code === "string") return e.code === "UNAUTHORIZED";
  const msg = (e?.message || "").toLowerCase();
  // permissive fallback; avoids tight coupling to exact wording
  return msg.includes("401") || msg.includes("unauthorized");
}
```

If you control `apiRequest`, consider standardizing the thrown error:

```ts
// client/src/lib/queryClient.ts (where apiRequest likely lives)
class HttpError extends Error {
  status?: number;
  code?: string;
  constructor(message: string, opts?: { status?: number; code?: string }) {
    super(message);
    this.status = opts?.status;
    this.code = opts?.code;
  }
}
```

### 2) DRY the unauthorized handling in mutations

You repeat the same 401 handling three times. Extract once:

```ts
function handleUnauthorized(toast: ReturnType<typeof useToast>["toast"]) {
  toast({
    title: "Unauthorized",
    description: "You are logged out. Logging in again...",
    variant: "destructive",
  });
  // give the toast a tick to render
  setTimeout(() => { window.location.href = "/api/login"; }, 500);
}
```

Then use it inside `onError` blocks:

```ts
onError: (error: Error) => {
  if (isUnauthorizedError(error)) {
    handleUnauthorized(toast);
    return;
  }
  toast({ title: "Error", description: error.message || "...", variant: "destructive" });
}
```

### 3) Guard edge cases in session state

* `canStartMining` can become `false` if `nextAvailable` is `null`/`undefined` even when the session is not active. Add a safer read.
* Also disable the START/STOP “button” while a mutation is pending to avoid double taps.

```ts
const isSessionActive = currentSession?.status === "active";
const nextAt = currentSession?.nextAvailable ? new Date(currentSession.nextAvailable) : null;
const canStartMining =
  !isSessionActive &&
  (!currentSession || (nextAt && nextAt <= new Date()));

const startOrStopDisabled =
  startMiningMutation.isPending || stopMiningMutation.isPending;
```

Apply to the clickable circle:

```tsx
<div
  className={`... ${startOrStopDisabled ? "opacity-60 pointer-events-none" : ""} ...`}
  onClick={() => {
    if (startOrStopDisabled) return;
    if (isSessionActive) stopMiningMutation.mutate();
    else if (canStartMining) startMiningMutation.mutate();
  }}
  data-testid="button-mining-toggle"
>
```

### 4) Countdown interval correctness & churn

Your `setInterval` is fine and cleared, but it re-creates every time `currentSession` changes (which is every 5s due to `refetchInterval`). That’s okay, but do one small resilience tweak so you don’t show negative times if the server clock skews:

```ts
const diff = Math.max(0, end - now);
```

Do the same for the cooldown diff.

### 5) Magic numbers → constants

Makes the ad system tunable:

```ts
const AD_MAX = 5;
const AD_STEP = 10; // percent
const BASE_REWARD = currentSession?.baseReward ?? 10;

const adCount = currentSession?.adBoostCount ?? 0;
const boostPercentage = currentSession?.boostPercentage ?? (adCount * AD_STEP);
const estimatedReward = Math.round(BASE_REWARD * (1 + boostPercentage / 100));
```

And use `AD_MAX`, `AD_STEP`, `adCount` everywhere (button disabled, progress, toast message).

### 6) Type the mutation responses

You use `data.xpReward` / `data.xnrtReward`. Give them a type to avoid anys:

```ts
type StopMiningResponse = {
  xpReward: number;
  xnrtReward?: number;
};

const stopMiningMutation = useMutation<StopMiningResponse>({
  mutationFn: async () => apiRequest("POST", "/api/mining/stop", {}),
  onSuccess: (data) => { /* unchanged */ }
});
```

### 7) Confetti: avoid crashes & unsupported shapes

* Use optional chaining with a default to avoid `featureFlags.ux` access errors.
* `canvas-confetti` supports `shapes: ['square','circle']`. `'star'` isn’t a stock shape and will be ignored; some builds may throw. Replace with supported shapes (or remove).
* Wrap in a `try/catch` so confetti can never crash the page.

```ts
// client/src/hooks/use-confetti.ts
import { useCallback } from 'react';
import confetti from 'canvas-confetti';
import { featureFlags } from '@/config/features';

export type CelebrationType = 'achievement' | 'streak' | 'levelup' | 'default';

export function useConfetti() {
  const celebrate = useCallback((type: CelebrationType = 'default') => {
    if (!featureFlags?.ux?.animations) return;

    const patterns: Record<CelebrationType, confetti.Options> = {
      achievement: {
        particleCount: 100,
        spread: 70,
        origin: { y: 0.6 },
        colors: ['#f59e0b', '#fbbf24', '#fcd34d'],
      },
      streak: {
        particleCount: 150,
        spread: 90,
        colors: ['#f97316', '#fb923c', '#fdba74'],
        shapes: ['circle'], // valid shape
      },
      levelup: {
        particleCount: 200,
        spread: 120,
        colors: ['#f59e0b', '#3b82f6', '#8b5cf6', '#ec4899'],
        shapes: ['square', 'circle'], // replaced 'star'
      },
      default: {
        particleCount: 100,
        spread: 70,
        colors: ['#f59e0b', '#fbbf24', '#fcd34d'],
      },
    };

    try {
      confetti(patterns[type]);
    } catch {
      // never let a celebration crash the UI
    }
  }, []);

  return { celebrate };
}
```

### 8) UX: button labels and a11y

Add `aria-label` to the main action and the ad button so screen readers announce intent:

```tsx
<p className="text-white font-bold" aria-label={isSessionActive ? "Stop mining" : "Start mining"}>
  {isSessionActive ? "STOP" : "START"}
</p>

<Button aria-label="Watch rewarded ad to add 10 percent mining boost" ...>
```

### 9) History list stability

If `MiningSession` lacks a guaranteed `id` (depends on your schema), use a composite key to avoid React key warnings:

```tsx
key={`${session.id ?? session.startTime}-${session.status}`}
```

### 10) Minor polish

* In success toast for stopping: guard `toFixed` on `xnrtReward` which can be undefined.

  ```ts
  const xnrt = data.xnrtReward;
  description: `You earned ${data.xpReward} XP${typeof xnrt === 'number' ? ` and ${xnrt.toFixed(1)} XNRT` : ""}!`
  ```
* The status badge variant currently uses `"default"` for both active and ready—if you want clearer color semantics, consider a custom class or `variant="secondary"` for one of them to differentiate.

---

## Summary of the most impactful changes

1. **Robust 401 detection** via `status`/`code` → fewer false negatives than a regex.
2. **Centralized unauthorized redirect** → less duplication and fewer inconsistencies.
3. **Safe confetti** (optional chaining + valid shapes + try/catch) → no UX-breaking errors.
4. **Disable start/stop during mutations** → prevents accidental double actions.
5. **Constants + types** for the ad system and mutation responses → easier tuning and safer refactors.
