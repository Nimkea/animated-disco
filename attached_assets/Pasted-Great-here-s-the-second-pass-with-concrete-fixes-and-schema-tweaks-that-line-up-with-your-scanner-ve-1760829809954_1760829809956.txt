Great—here’s the second-pass with concrete fixes and schema tweaks that line up with your scanner/verify code.

# 1) `hdWallet.ts` — switch to EVM (coin type 60) + harden

**Why:** MetaMask/BSC derives on `60`, not `714`. Keep legacy addrs scanning, but start issuing 60 now.

```ts
// ✅ drop-in replacement
import { ethers } from "ethers";

const MASTER_SEED_ENV = "MASTER_SEED";
const BSC_DERIVATION_PATH = "m/44'/60'/0'/0"; // <-- fix

export function deriveDepositAddress(derivationIndex: number): string {
  if (!Number.isInteger(derivationIndex) || derivationIndex < 0)
    throw new Error("derivationIndex must be a non-negative integer");

  const seed = process.env[MASTER_SEED_ENV];
  if (!seed) throw new Error("MASTER_SEED environment variable not set");

  const words = seed.trim().split(/\s+/);
  if (words.length !== 12 && words.length !== 24)
    throw new Error("MASTER_SEED must be a 12 or 24 word mnemonic phrase");

  const m = ethers.Mnemonic.fromPhrase(seed.trim());
  const path = `${BSC_DERIVATION_PATH}/${derivationIndex}`;
  return ethers.HDNodeWallet.fromMnemonic(m, path).address.toLowerCase();
}
```

(Optionally gate `getDerivedPrivateKey` behind `ALLOW_SWEEPING_KEYS==='true'`.)

# 2) `verifyBscUsdt.ts` — add 30s timeout + single tip read

```ts
import { ethers } from "ethers";

const req = new ethers.FetchRequest(process.env.RPC_BSC_URL!);
req.timeout = 30_000;
const provider = new ethers.JsonRpcProvider(req);
```

(Use one `getBlockNumber()` per call as in my previous patch; everything else looks fine.)

# 3) `depositScanner.ts` — idempotency + “pending” branch

* You scan only to `tip - confirmations` ⇒ `confirmations >= REQUIRED_CONFIRMATIONS` is always true.
  **Either** remove the “pending” branch (simplest) **or** scan to tip and promote `pending→approved` later.
* Make credit **idempotent** with a DB unique that matches how you process events.

### Recommended DB constraint

You currently have `transactionHash` **nullable** but `@unique`:

```prisma
transactionHash String? @unique @db.Text
```

This blocks crediting two different deposit addresses if (rarely) a single tx transfers to multiple user addrs. Prefer a **composite** unique:

```prisma
model Transaction {
  // ...
  transactionHash String? @db.Text
  walletAddress   String?
  // ...
  @@unique([transactionHash, walletAddress]) // <— replace single-column unique
}
```

Then in the scanner, check this composite key inside the transaction (or `upsert`).

---

# 4) Prisma schema review (what to change)

## A) Support multiple deposit addresses per user (legacy 714 + new 60)

Today `User` has a **single** `depositAddress` and `derivationIndex`. To rotate/address-v2 while still scanning legacy addresses, add a table:

```prisma
model DepositAddress {
  id              String   @id @default(uuid())
  userId          String
  address         String   @unique @db.VarChar(42) // store lowercased
  coinType        Int                      // 60 or 714
  derivationIndex Int
  derivationPath  String
  version         Int       @default(2)     // 1=legacy(714), 2=current(60)
  active          Boolean   @default(true)
  createdAt       DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([coinType, derivationIndex])
  @@index([userId, active])
}
```

Keep the existing `User.depositAddress/derivationIndex` for backward compatibility, but start writing to `DepositAddress` and (optionally) mirror the **current** one back to `User.depositAddress` for UI.

**Scanner change:** build `addressToUserId` from `DepositAddress` (active ones), not from `User.depositAddress`.

```ts
const addrs = await prisma.depositAddress.findMany({
  where: { active: true },
  select: { userId: true, address: true }
});
addrs.forEach(a => map.set(a.address.toLowerCase(), a.userId));
```

## B) Replace `Transaction.transactionHash` unique with composite (as above)

Migration plan below.

## C) Enums (optional but safer)

Replace free-form strings to prevent typos:

```prisma
enum TxType { deposit withdrawal reward stake }
enum TxStatus { pending approved rejected }

model Transaction {
  // ...
  type   TxType
  status TxStatus @default(pending)
}
```

---

# 5) Migration plan (non-destructive)

1. **Add `DepositAddress` table**

   ```
   npx prisma migrate dev --name add_deposit_address_table
   ```

   Then backfill: for each user with `depositAddress != null`, insert a `DepositAddress` row:

   * `coinType=714` if that’s how you originally derived; set `version=1`.
   * mark `active=true` for the one you display today.

2. **Introduce composite unique for Transaction**

   * Create a new migration that:

     * Drops the existing unique index on `Transaction.transactionHash`
     * Adds `@@unique([transactionHash, walletAddress])`

   Prisma migration (SQL-ish idea):

   ```sql
   DROP INDEX IF EXISTS "Transaction_transactionHash_key";
   CREATE UNIQUE INDEX "Transaction_txhash_wallet_key"
     ON "Transaction" ("transactionHash", "walletAddress");
   ```

3. **Code updates**

   * Switch HD coin type to **60**.
   * Scanner: map from `DepositAddress` instead of `User`.
   * Credit path: guard with the composite key; use `upsert` or early-return after `findUnique`.
   * UI: show checksum (`ethers.getAddress(addr)`) but always **store lowercased**.

---

# 6) Quick sanity checklist

* [ ] `hdWallet.ts` path is `m/44'/60'/0'/0/{index}`.
* [ ] New `DepositAddress` rows created for existing users; scanner watches them.
* [ ] Composite unique on `(transactionHash, walletAddress)` is live.
* [ ] Scanner credit path is idempotent (no double credit across retries).
* [ ] `verifyBscUsdt.ts` uses 30s timeout provider.

If you want, I can sketch the **backfill script** to populate `DepositAddress` from `User.depositAddress` and create new v2 (coinType 60) addresses for users who don’t have one yet.
