Awesome—here’s a **drop-in backend pack** for your current stack (Express + TypeScript + Prisma, ESM). It includes:

* the USDT-on-BSC **verification service** (ethers v6)
* **routes** for user submit, admin verify, approve/reject, bulk actions
* a tiny **Prisma client helper**
* a safe **approve** function (idempotent, transactional)
* minimal **server/index.ts** wiring

> Assumes you added these secrets in Replit → App Secrets:
> `RPC_BSC_URL`, `USDT_BSC_ADDRESS=0x55d398326f99059fF775485246999027B3197955`, `XNRT_WALLET`, `BSC_CONFIRMATIONS=12`, `XNRT_RATE_USDT=100`, `PLATFORM_FEE_BPS=50`.

---

# 1) `server/lib/prisma.ts`

```ts
// server/lib/prisma.ts
import { PrismaClient } from "@prisma/client";
export const prisma = new PrismaClient();
```

---

# 2) `server/services/verifyBscUsdt.ts`

```ts
// server/services/verifyBscUsdt.ts
import "dotenv/config";
import { ethers } from "ethers";

const provider = new ethers.JsonRpcProvider(process.env.RPC_BSC_URL);
const USDT_ABI = [
  "event Transfer(address indexed from, address indexed to, uint256 value)"
];

const usdt = new ethers.Contract(
  process.env.USDT_BSC_ADDRESS!,
  USDT_ABI,
  provider
);

export type VerifyResult = {
  verified: boolean;
  confirmations: number;
  amountOnChain?: number;
  reason?: string;
};

export async function verifyBscUsdtDeposit(params: {
  txHash: string;
  expectedTo: string;        // XNRT wallet (or per-user deposit address)
  minAmount?: number;        // USDT amount user claimed
  requiredConf?: number;     // default 12
}): Promise<VerifyResult> {
  try {
    const { txHash, expectedTo } = params;
    const need = params.requiredConf ?? Number(process.env.BSC_CONFIRMATIONS ?? 12);

    const receipt = await provider.getTransactionReceipt(txHash);
    if (!receipt) return { verified: false, confirmations: 0, reason: "Transaction not found" };
    if (receipt.status !== 1) {
      const conf = (await provider.getBlockNumber()) - (receipt.blockNumber ?? 0);
      return { verified: false, confirmations: conf, reason: "Transaction failed" };
    }

    let totalToExpected = 0n;

    for (const log of receipt.logs) {
      if (log.address.toLowerCase() !== process.env.USDT_BSC_ADDRESS!.toLowerCase()) continue;
      try {
        const parsed = usdt.interface.parseLog({ topics: log.topics, data: log.data });
        if (parsed?.name !== "Transfer") continue;
        const to: string = (parsed.args as any).to;
        const value: bigint = (parsed.args as any).value;
        if (to.toLowerCase() === expectedTo.toLowerCase()) {
          totalToExpected += value;
        }
      } catch {
        // ignore non-transfer logs
      }
    }

    const conf = (await provider.getBlockNumber()) - (receipt.blockNumber ?? 0);
    if (totalToExpected === 0n) {
      return { verified: false, confirmations: conf, reason: "No USDT transfer to expected address" };
    }

    // USDT (BSC) has 18 decimals
    const amountFloat = Number(ethers.formatUnits(totalToExpected, 18));
    if (typeof params.minAmount === "number" && amountFloat + 1e-10 < params.minAmount) {
      return { verified: false, confirmations: conf, reason: `On-chain ${amountFloat} < claimed ${params.minAmount}` };
    }

    if (conf < need) {
      return { verified: false, confirmations: conf, amountOnChain: amountFloat, reason: `Only ${conf}/${need} confirmations` };
    }

    return { verified: true, confirmations: conf, amountOnChain: amountFloat };
  } catch (e: any) {
    return { verified: false, confirmations: 0, reason: e?.message ?? "Verify error" };
  }
}
```

---

# 3) `server/routes/deposits.ts`

```ts
// server/routes/deposits.ts
import "dotenv/config";
import { Router } from "express";
import { prisma } from "../lib/prisma.js";
import { verifyBscUsdtDeposit } from "../services/verifyBscUsdt.js";

// If you already have real middlewares, import them instead:
const requireAuth: any = (req: any, res: any, next: any) => {
  // replace with your real auth; expect req.user.id
  if (!req.user?.id) return res.status(401).json({ error: "Unauthorized" });
  next();
};
const requireAdmin: any = (req: any, res: any, next: any) => {
  if (!req.user?.isAdmin) return res.status(403).json({ error: "Forbidden" });
  next();
};

const r = Router();
const TX_HASH_RE = /^0x[a-fA-F0-9]{64}$/;

// USER submits deposit request (hash + claimed USDT amount)
r.post("/api/transactions/deposit", requireAuth, async (req, res) => {
  const userId = req.user.id as string;
  const { usdtAmount, transactionHash, proofImageUrl } = req.body ?? {};

  if (!TX_HASH_RE.test(transactionHash ?? "")) {
    return res.status(400).json({ error: "Invalid tx hash" });
  }
  const amt = Number(usdtAmount);
  if (!amt || amt <= 0) return res.status(400).json({ error: "Invalid amount" });

  const xnrtRate = Number(process.env.XNRT_RATE_USDT ?? 100);
  const feeBps  = Number(process.env.PLATFORM_FEE_BPS ?? 0);
  const net     = amt * (1 - feeBps / 10_000);
  const xnrt    = net * xnrtRate;

  try {
    const dep = await prisma.deposit.create({
      data: {
        userId,
        network: "BSC",
        asset: "USDT",
        transactionHash,
        toAddress: process.env.XNRT_WALLET!,  // the wallet you show in UI
        usdtAmount: amt.toString(),
        xnrtAmount: xnrt.toString(),
        status: "pending",
        verified: false,
        proofImageUrl: proofImageUrl || null,
      },
    });
    res.json(dep);
  } catch (e: any) {
    if (e?.code === "P2002") return res.status(409).json({ error: "TX already submitted" });
    throw e;
  }
});

// ADMIN: list all pending deposits
r.get("/api/admin/deposits/pending", requireAdmin, async (_req, res) => {
  const rows = await prisma.deposit.findMany({
    where: { status: "pending" },
    orderBy: { createdAt: "desc" },
    include: { user: { select: { email: true, username: true } } },
  });
  res.json(rows);
});

// ADMIN: verify one deposit (on-chain check)
r.post("/api/admin/deposits/:id/verify", requireAdmin, async (req, res) => {
  const dep = await prisma.deposit.findUnique({ where: { id: req.params.id } });
  if (!dep) return res.status(404).json({ error: "Not found" });

  const result = await verifyBscUsdtDeposit({
    txHash: dep.transactionHash,
    expectedTo: dep.toAddress,
    minAmount: Number(dep.usdtAmount),
    requiredConf: Number(process.env.BSC_CONFIRMATIONS ?? 12),
  });

  if (result.verified) {
    await prisma.deposit.update({
      where: { id: dep.id },
      data: { verified: true, confirmations: result.confirmations, raw: result as any },
    });
  }
  res.json(result);
});

// INTERNAL: approve helper (transactional + idempotent)
async function approveAndCredit(depositId: string, adminNotes?: string) {
  return prisma.$transaction(async (tx) => {
    const dep = await tx.deposit.findUnique({ where: { id: depositId } , lock: { mode: "ForUpdate" }});
    if (!dep) throw new Error("Deposit not found");
    if (dep.status !== "pending") return dep; // idempotent exit
    if (!dep.verified) throw new Error("Deposit not verified");

    // credit XNRT balance
    await tx.balance.upsert({
      where: { userId_asset: { userId: dep.userId, asset: "XNRT" } },
      create: { userId: dep.userId, asset: "XNRT", amount: dep.xnrtAmount },
      update: { amount: (BigInt(dep.xnrtAmount) + BigInt(await getCurrentAmount(tx, dep.userId))).toString() }
    });

    // trade record
    await tx.trade.create({
      data: {
        userId: dep.userId,
        fromAsset: "USDT",
        toAsset: "XNRT",
        fromAmount: dep.usdtAmount,
        toAmount: dep.xnrtAmount,
        rate: String(process.env.XNRT_RATE_USDT ?? "100"),
        fee: "0", // optional: compute from PLATFORM_FEE_BPS
        refTx: dep.transactionHash,
      },
    });

    const updated = await tx.deposit.update({
      where: { id: dep.id },
      data: { status: "approved", processedAt: new Date(), adminNotes: adminNotes ?? null },
    });

    return updated;
  });
}

// helper to read current XNRT balance as bigint (string decimals safe)
async function getCurrentAmount(tx: any, userId: string): Promise<string> {
  const b = await tx.balance.findUnique({ where: { userId_asset: { userId, asset: "XNRT" } }});
  return b?.amount ?? "0";
}

// ADMIN: approve one
r.post("/api/admin/deposits/:id/approve", requireAdmin, async (req, res) => {
  try {
    const updated = await approveAndCredit(req.params.id, req.body?.notes);
    res.json(updated);
  } catch (e: any) {
    res.status(400).json({ error: e?.message ?? "Approve failed" });
  }
});

// ADMIN: reject one
r.post("/api/admin/deposits/:id/reject", requireAdmin, async (req, res) => {
  const updated = await prisma.deposit.update({
    where: { id: req.params.id },
    data: { status: "rejected", adminNotes: req.body?.notes ?? null },
  });
  res.json(updated);
});

// ADMIN: bulk approve (only IDs you pass)
r.post("/api/admin/deposits/bulk-approve", requireAdmin, async (req, res) => {
  const ids: string[] = req.body?.depositIds ?? [];
  let approved = 0, failed = 0;

  for (const id of ids) {
    try { await approveAndCredit(id, req.body?.notes); approved++; }
    catch { failed++; }
  }
  res.json({ approved, failed, total: ids.length });
});

// ADMIN: bulk reject
r.post("/api/admin/deposits/bulk-reject", requireAdmin, async (req, res) => {
  const ids: string[] = req.body?.depositIds ?? [];
  let rejected = 0, failed = 0;

  for (const id of ids) {
    try {
      await prisma.deposit.update({ where: { id }, data: { status: "rejected", adminNotes: req.body?.notes ?? null } });
      rejected++;
    } catch { failed++; }
  }
  res.json({ rejected, failed, total: ids.length });
});

export default r;
```

> The balance math above uses strings to avoid float drift. If your `Balance.amount` is a `Decimal` in Prisma, you can replace with numeric-safe operations (or use a tiny helper that adds decimal strings).

---

# 4) **Wire it up** in `server/index.ts`

If you already have an Express app, just mount the router:

```ts
// server/index.ts
import "dotenv/config";
import express from "express";
import cors from "cors";
import helmet from "helmet";
import session from "express-session";
// import your real auth session middleware here

import depositsRouter from "./routes/deposits.js";

const app = express();
app.use(cors());
app.use(helmet());
app.use(express.json({ limit: "2mb" }));

// TODO: your session + passport wiring
// app.use(session(...));
// app.use(passport.initialize());
// app.use(passport.session());

app.use(depositsRouter);

app.get("/healthz", (_req, res) => res.json({ ok: true }));

const port = process.env.PORT || 3000;
app.listen(port, () => {
  console.log(`API listening on :${port}`);
});
```

---

## Optional: Prisma Models (if you haven’t created them yet)

Mirror these in `schema.prisma` (or your Drizzle migrations):

```prisma
model User {
  id        String   @id @default(cuid())
  email     String   @unique
  username  String?
  createdAt DateTime @default(now())
  deposits  Deposit[]
  balances  Balance[]
  trades    Trade[]
}

model Deposit {
  id              String   @id @default(cuid())
  userId          String
  user            User     @relation(fields: [userId], references: [id])
  network         String
  asset           String
  transactionHash String   @unique
  toAddress       String
  usdtAmount      String   // store as string/Decimal
  xnrtAmount      String
  status          String   // pending | approved | rejected
  verified        Boolean  @default(false)
  confirmations   Int      @default(0)
  proofImageUrl   String?
  adminNotes      String?
  raw             Json?
  createdAt       DateTime @default(now())
  processedAt     DateTime?

  @@index([status, createdAt])
  @@index([userId, createdAt])
}

model Balance {
  userId String
  asset  String
  amount String  // or Decimal

  user   User    @relation(fields: [userId], references: [id])
  @@id([userId, asset])
}

model Trade {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id])
  fromAsset   String
  toAsset     String
  fromAmount  String
  toAmount    String
  rate        String
  fee         String
  refTx       String?
  createdAt   DateTime @default(now())

  @@index([userId, createdAt])
}
```

Run:

```bash
npm run prisma:generate
# then your migration flow (if using migrate): prisma migrate dev
```

---

## Quick sanity checklist

* [ ] Add the 5 secrets in Replit (RPC_BSC_URL, USDT_BSC_ADDRESS, XNRT_WALLET, BSC_CONFIRMATIONS, XNRT_RATE_USDT).
* [ ] Install deps: `npm i ethers dotenv`.
* [ ] Paste the 4 files above.
* [ ] Start API.
* [ ] Submit a real BSC USDT tx hash in the app → Admin → **Verify** → **Approve** → XNRT credited.

If you want, I can also give you a **tiny cron/worker** that auto-verifies all `pending` deposits every minute and auto-approves those under a threshold (e.g., ≤ 100 USDT).
