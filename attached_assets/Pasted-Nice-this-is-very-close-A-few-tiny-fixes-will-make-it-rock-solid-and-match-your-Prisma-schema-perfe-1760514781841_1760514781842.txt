Nice—this is very close. A few tiny fixes will make it rock-solid and match your Prisma schema perfectly.

## What to change (surgical)

1. **When users create a deposit**

* Save the destination wallet (`walletAddress`) so the admin can see it and so the verifier can compare against the same address.
* Optionally apply a platform fee via `PLATFORM_FEE_BPS` (keep `0` if you don’t charge a fee).
* Add a basic tx-hash sanity check.

```ts
// in /api/transactions/deposit
app.post('/api/transactions/deposit', requireAuth, validateCSRF, async (req, res) => {
  try {
    const userId = req.authUser!.id;
    const { usdtAmount, transactionHash, proofImageUrl } = req.body;

    if (!usdtAmount || !transactionHash) {
      return res.status(400).json({ message: "Missing required fields" });
    }

    // tx hash quick validation
    if (!/^0x[a-fA-F0-9]{64}$/.test(transactionHash)) {
      return res.status(400).json({ message: "Invalid transaction hash format" });
    }

    if (proofImageUrl) {
      const isBase64DataUrl = proofImageUrl.startsWith('data:image/');
      const isValidUrl = /^https?:\/\//.test(proofImageUrl);
      if (!isBase64DataUrl && !isValidUrl) {
        return res.status(400).json({ message: "Invalid proof image URL format" });
      }
    }

    const rate = Number(process.env.XNRT_RATE_USDT ?? 100);
    const feeBps = Number(process.env.PLATFORM_FEE_BPS ?? 0); // 0 if you don’t charge
    const usdt = Number(usdtAmount);
    const netUsdt = usdt * (1 - feeBps / 10_000);
    const xnrtAmount = netUsdt * rate;

    const transaction = await storage.createTransaction({
      userId,
      type: "deposit",
      amount: xnrtAmount.toString(),      // XNRT to credit after fee
      usdtAmount: usdt.toString(),        // raw USDT
      transactionHash,
      walletAddress: process.env.XNRT_WALLET!, // <-- persist destination
      ...(proofImageUrl && { proofImageUrl }),
      status: "pending",
      verified: false,
      confirmations: 0
    });

    res.json(transaction);
  } catch (error) {
    console.error("Error creating deposit:", error);
    res.status(500).json({ message: "Failed to create deposit" });
  }
});
```

2. **Verification (admin)**

* You already call `verifyBscUsdtDeposit`. Make sure we compare to the same address we saved (fallback to env).

```ts
// /api/admin/deposits/:id/verify (unchanged logic, tiny tweak)
const result = await verifyBscUsdtDeposit({
  txHash: deposit.transactionHash,
  expectedTo: deposit.walletAddress || process.env.XNRT_WALLET!, // <--
  minAmount: deposit.usdtAmount ? parseFloat(deposit.usdtAmount) : undefined,
  requiredConf: Number(process.env.BSC_CONFIRMATIONS ?? 12),
});
```

3. **Approval must require verification + do atomic credit**

* Prevent approving if not verified, and do atomic increments to avoid race conditions.

```ts
import { Prisma } from "@prisma/client";

// single approve
app.post('/api/admin/deposits/:id/approve', requireAuth, requireAdmin, validateCSRF, async (req, res) => {
  try {
    const { id } = req.params;
    const dep = await storage.getTransactionById(id);
    if (!dep || dep.type !== "deposit") return res.status(404).json({ message: "Deposit not found" });
    if (dep.status !== "pending") return res.status(400).json({ message: "Deposit already processed" });
    if (!dep.verified) return res.status(400).json({ message: "Deposit not verified on-chain yet" });

    await prisma.$transaction(async (tx) => {
      // credit safely using increment
      await tx.balance.upsert({
        where: { userId: dep.userId },
        create: {
          userId: dep.userId,
          xnrtBalance: new Prisma.Decimal(dep.amount),
          totalEarned: new Prisma.Decimal(dep.amount),
        },
        update: {
          xnrtBalance: { increment: new Prisma.Decimal(dep.amount) },
          totalEarned: { increment: new Prisma.Decimal(dep.amount) },
        },
      });

      await tx.transaction.update({
        where: { id },
        data: {
          status: "approved",
          approvedBy: req.authUser!.id,
          approvedAt: new Date(),
        },
      });
    });

    // (optional) distribute referrals + activity + notify (your existing calls)
    await storage.distributeReferralCommissions(dep.userId, parseFloat(dep.amount));
    await storage.createActivity({
      userId: dep.userId,
      type: "deposit_approved",
      description: `Deposit of ${parseFloat(dep.amount).toLocaleString()} XNRT approved`,
    });

    res.json({ message: "Deposit approved successfully" });
  } catch (error) {
    console.error("Error approving deposit:", error);
    res.status(500).json({ message: "Failed to approve deposit" });
  }
});
```

```ts
// bulk approve – add the verified check and use increment style in a tx
// (inside your loop, before updating balance)
if (!deposit.verified) {
  throw new Error(`Deposit ${id} not verified`);
}

await prisma.$transaction(async (tx) => {
  await tx.balance.upsert({
    where: { userId: deposit.userId },
    create: {
      userId: deposit.userId,
      xnrtBalance: new Prisma.Decimal(deposit.amount),
      totalEarned: new Prisma.Decimal(deposit.amount),
    },
    update: {
      xnrtBalance: { increment: new Prisma.Decimal(deposit.amount) },
      totalEarned: { increment: new Prisma.Decimal(deposit.amount) },
    },
  });

  await tx.transaction.update({
    where: { id },
    data: { 
      status: "approved",
      adminNotes: notes || deposit.adminNotes,
      approvedBy: req.authUser!.id,
      approvedAt: new Date(),
    },
  });
});
```

## Env you should have (Replit → Secrets)

```
# BSC mainnet (public RPC is fine for now)
RPC_BSC_URL=https://bsc-dataseed.binance.org

# USDT on BSC
USDT_BSC_ADDRESS=0x55d398326f99059fF775485246999027B3197955

# Your receive address (you renamed it to “XNRT Wallet” in UI)
XNRT_WALLET=0x715C32deC9534d2fB34e0B567288AF8d895efB59

# Policy knobs
BSC_CONFIRMATIONS=12
XNRT_RATE_USDT=100
PLATFORM_FEE_BPS=0
```

## Why this fixes the “Failed to create deposit”

* The create route now only writes fields that exist in your **Transaction** model.
* `walletAddress` is stored (matches your schema).
* Proof URL validation can no longer poison the insert.
* Approvals are safe and idempotent (increment ops inside a single DB tx).
* Admins can’t accidentally approve unverified deposits.

If you paste these small blocks into your file where noted, your deposit flow should be clean end-to-end.
